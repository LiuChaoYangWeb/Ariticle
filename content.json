[{"title":"js数组去重","date":"2017-08-22T11:33:54.197Z","path":"2017/08/22/数组去重/","text":"总结了一下数组去重的方法: 利用 indexOf 进行数组去重 12345678910var arr = [1,2,2,3,4,5,6,7,8,9,0,2,3,5,8,9,0,1];var arr1 = [];for( var i = 0; i &lt; arr.length; i++)&#123; //ES5中引入了 indexOf 方法 if( arr1.indexOf( arr[i] ) == -1 )&#123; arr1.push( arr[i] ); &#125;&#125;console.log( arr1 ); 假设法去重 123456789101112131415161718var arr = [1,2,2,3,4,5,6,7,8,9,0,2,3,5,8,9,0,1];var arr1 = [];for( var i = 0; i &lt; arr.length; i++)&#123; var flag = true; for( var j = 0; j &lt; arr1.length; j ++)&#123; if( arr1[ j ] == arr[ i ])&#123; flag = false; break; &#125; &#125; if( flag )&#123; arr1.push( arr[ i ]); &#125;&#125;console.log( arr1 ); 利用缓存对象实现数组去重 12345678910111213var arr = [1,2,2,3,4,5,6,7,8,9,0,2,3,5,8,9,0,1];var cache = &#123;&#125;, arr1 = [];for( var i = 0; i &lt; arr.length; i ++ )&#123; if( !cache[ arr[ i ]]) &#123; cache[ arr[ i ]] = true; arr1.push( arr[ i ] ); &#125;&#125;console.log( arr1 ); ES6数组去重 ES6里新添加了两个很好用的东西，set和Array.from。set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去重其中的重复项目。 在这我们可以看见，重复的项目已经被去掉了，包括NaN。正常情况下，NaN === NaN 返回的是false，但是在set里，一样能够帮你去重，厉害了。 set返回的是一个对象，但是我们想要的是数组啊。这回，就该轮到Array.from出场了，它的作用，就是可以把类数组对象、可迭代对象转化为数组。 兼容性 目前主流的浏览器，Chrome,Firfox,Opera，Safari，包括微软的Edge,都是支持的，唯独IE系列不支持","tags":[{"name":"js数组","slug":"js数组","permalink":"https://hudadahexiaolili.github.io/tags/js数组/"}]},{"title":"理解盒子模型","date":"2017-05-11T16:00:00.000Z","path":"2017/05/12/css盒子模型/","text":"理解CSS盒子模型概述 网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)，CSS盒子模型都具备这些属性，也主要是这些属性。 这些属性我们可以把它转移到我们日常生活中的盒子(箱子)上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模型。 CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 盒子模型是css中一个重要的概念，理解了盒子模型才能更好的排版。其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型。他们对盒子模型的解释各不相同。 标准盒子模型 从上图可以看到标准 w3c 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 ie 盒子模型 从上图可以看到 ie 盒子模型的范围也包括 margin、border、padding、content，和标准 w3c 盒子模型不同的是：ie 盒子模型的 content 部分包含了 border 和 pading。 例：一个盒子的 margin 为 20px，border 为 1px，padding 为 10px，content 的宽为 200px、高为 50px，假如用标准 w3c 盒子模型解释，那么这个盒子需要占据的位置为：宽 202+12+102+200=262px、高 202+12102+50=112px，盒子的实际大小为：宽 12+102+200=222px、高 12+102+50=72px；假如用ie 盒子模型，那么这个盒子需要占据的位置为：宽 202+200=240px、高 20*2+50=70px，盒子的实际大小为：宽 200px、高 50px。 在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 1231. 提示：背景应用于由内容和内边距、边框组成的区域。2. 示：内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。3. 提示：外边距可以是负值，而且在很多情况下都要使用负值的外边距。 浏览器兼容性 一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。 那我们开发的时候选择哪中盒子模型呢？肯定是“标准 w3c 盒子模型”。怎么样才算是选择了“标准 w3c 盒子模型”呢？很简单，就是在网页的顶部加上 doctype 声明。假如不加 doctype 声明，那么各个浏览器会根据自己的行为去理解网页，即 ie 浏览器会采用 ie 盒子模型去解释你的盒子，而 ff 会采用标准 w3c 盒子模型解释你的盒子，所以网页在不同的浏览器中就显示的不一样了。反之，假如加上了 doctype 声明，那么所有浏览器都会采用标准 w3c 盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了。 所以为了让网页能兼容各个浏览器，让我们用标准 w3c 盒子模型。 CSS3 box-sizing 属性 定义和用法box-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素。box-sizing有两个值一个是content-box，另一个是border-box。当设置为box-sizing:content-box时，将采用*标准模式*解析计算，也是默认模式；当设置为box-sizing:border-box时，将采用*怪异模式*解析计算；目前使用此属性需要前缀如下: 123-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box|border-box|inherit; 例如，假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 “border-box”。这可令浏览器以怪异模式呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。","tags":[{"name":"css","slug":"css","permalink":"https://hudadahexiaolili.github.io/tags/css/"}]},{"title":"Vue-router从入门到入门","date":"2017-05-10T16:00:00.000Z","path":"2017/05/11/v-router的学习/","text":"get started 用 Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。 你可以看看这个例子 动态路由匹配 你可以看看这个例子 路由嵌套 你可以看看这个例子 更多的内容(编程式导航、命名路由、重定向、导航钩子等)可以参照Vue-router官网","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://hudadahexiaolili.github.io/tags/Vue-js/"},{"name":"v-router","slug":"v-router","permalink":"https://hudadahexiaolili.github.io/tags/v-router/"}]},{"title":"npm 列出所有可以用的版本的命令","date":"2017-04-12T16:00:00.000Z","path":"2017/04/13/npm/","text":"npm info xxx npm view xxx versions 安装指定版本 首先确保文件目录下含有package.json文件，没有的话，可以通过npm init创建，然后只需要在组件的后面加上@2.8.1版本号即可，例如：react-router已经更新到4.x版本，想要下载2.x版本，可以通过下面命令 1npm install --save-dev react-router@2.8.1 下载完成，可以在package.json 文件下，查看react-router版本","tags":[{"name":"nrm","slug":"nrm","permalink":"https://hudadahexiaolili.github.io/tags/nrm/"}]},{"title":"nrm切换npm源利器","date":"2017-04-11T16:00:00.000Z","path":"2017/04/12/nrm/","text":"在使用npm时，官方的源下载npm包会比较慢，国内我们基本使用淘宝的源，最近公司内部搭建了一套npm私有仓库。要添加自己公司内部的npm源，公司内部的源不可能把npm官方的npm包都全量同步，故需要npm源之间的切换，如果使用npm registry xxx的话，太不好管理了。nrm是管理npm源切换的利器。使用方法如下： 安装nrm 1npm install -g nrm nrm --help 帮助命令 123456789101112131415161718Usage: nrm [options] [command] Commands: ls list all the registries current show current registry name use &lt;registry&gt; change registry to registry add &lt;registry&gt; &lt;url&gt; [home] add one custom registry del|rm &lt;registry&gt; delete one custom registry home &lt;registry&gt; [browser] open the homepage of registry with optional browser test [registry] show response time for specific or all registries help print this help Options: -h, --help output usage information -V, --version output the version number nrm ls是列出来现在已经配置好的所有的原地址 123456npm ---- https://registry.npmjs.org/* cnpm --- http://r.cnpmjs.org/ taobao - http://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn npmMirror https://skimdb.npmjs.com/registry nrm use npm nrm add 添加源 nrm del 删除源 nrm test 测试源的响应时间，可以作为使用哪个源的参考","tags":[{"name":"nrm","slug":"nrm","permalink":"https://hudadahexiaolili.github.io/tags/nrm/"}]},{"title":"Vue组件学习","date":"2017-03-11T16:00:00.000Z","path":"2017/03/12/vue组件/","text":"Vue组件 组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树： 全局组件 注册一个全局组件语法格式如下： 1Vue.component(tagName, options) tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件： 1&lt;tagName&gt;&lt;/tagName&gt; 全局组件实例 所有实例都能用全局组件。 123456789101112131415//注册一个简单的全局组件 runoob，并使用它：&lt;div id=\"app\"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('runoob', &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 局部组件 我们也可以在实例选项中注册局部组件，这样组件只能在这个实例中使用： 局部组件实例 12345678910111213141516171819//注册一个简单的局部组件 runoob，并使用它：&lt;div id=\"app\"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;var Child = &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125; // 创建根实例new Vue(&#123; el: '#app', components: &#123; // &lt;runoob&gt; 将只在父模板可用 'runoob': Child &#125;&#125;)&lt;/script&gt; Prop prop 是父组件用来传递数据的一个自定义属性。 父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 “prop”： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;child message=\"hello!\"&gt;&lt;/child&gt;&lt;/div&gt; &lt;script&gt;//注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 \"this.message\" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; Tips: props:[‘info’]在方法中使用this.info访问，在模板中使用 动态Prop 类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件： 123456789101112131415161718192021222324&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:message=\"parentMsg\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 \"this.message\" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app', data: &#123; parentMsg: '父组件内容' &#125;&#125;)&lt;/script&gt; 自定义事件 父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件！我们可以使用 v-on 绑定自定义事件, 每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 1234567891011121314151617181920212223242526272829303132&lt;div id=\"app\"&gt; &lt;login v-on:send=\"getData\"&gt;&lt;/login&gt;&lt;/div&gt;&lt;script&gt; // vue对象默认可以看成是一个跟组件 var vm = new Vue(&#123; el: '#app', methods: &#123; getData: function (id) &#123; alert(id) &#125; &#125;, components: &#123; 'login': &#123; template: '这是个login组件----&lt;button @click=\"sendData\"&gt;点击以后子组件向父组件传值&lt;/button&gt;', //data必须是个函数，否则报错 data:function()&#123; return &#123; id:12 &#125; &#125;, methods: &#123; sendData: function () &#123; this.$emit('send', this.id) &#125; &#125;, &#125; &#125; &#125;)&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; &lt;div id=\"counter-event-example\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;,&#125;)new Vue(&#123; el: '#counter-event-example', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125;&#125;)&lt;/script&gt; 如果你想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。例如：1&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://hudadahexiaolili.github.io/tags/Vue-js/"},{"name":"vue组件","slug":"vue组件","permalink":"https://hudadahexiaolili.github.io/tags/vue组件/"}]},{"title":"Vue指令学习","date":"2017-03-04T16:00:00.000Z","path":"2017/03/05/vue指令/","text":"Vue指令 指令 (Directives) 是特殊的带有前缀 v- 的特性。指令的值限定为绑定表达式，因此上面提到的 JavaScript 表达式及过滤器规则在这里也适用。指令的职责就是当其表达式的值改变时把某些特殊的行为应用到 DOM 上。 在Vue中，常用的指令有v-text、v-html、v-if、v-show、v-for、v-on、v-bind、v-model、v-ref、v-el、v-pre、v-cloak。 先上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script type=\"text/javascript\" src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .item &#123; margin: 1px; padding: 5px 0 5px 0; &#125; .item:hover &#123; background: #cccccc; &#125; &lt;/style&gt; &lt;/head&gt; &lt;div id=\"dr01\"&gt; &lt;h3&gt;v-text&lt;/h3&gt; &lt;div v-text=\"msgText\"&gt;&lt;/div&gt; &lt;div&gt;&#123;&#123;msgText&#125;&#125;&lt;/div&gt; &lt;hr /&gt; &lt;h3&gt;v-html&lt;/h3&gt; &lt;div v-html=\"msgHtml\"&gt;&lt;/div&gt; &lt;div&gt;&#123;&#123;&#123;msgHtml&#125;&#125;&#125;&lt;/div&gt; &lt;hr /&gt; &lt;h3&gt;v-if&lt;/h3&gt; &lt;div&gt;msgBoolean01:true&lt;/div&gt; &lt;div v-if=\"msgBoolean01\"&gt;(here is v-if code block)if msgBoolean01 is true show this div&lt;/div&gt; &lt;div v-else&gt;(here is v-else code block)if msgBoolean01 is false show this div&lt;/div&gt; &lt;br /&gt; &lt;div&gt;msgBoolean01:false&lt;/div&gt; &lt;div v-if=\"msgBoolean02\"&gt;(here is v-if code block)if msgBoolean02 is true show this div&lt;/div&gt; &lt;div v-else&gt;(here is v-else code block)if msgBoolean02 is false show this div&lt;/div&gt; &lt;h3&gt;template v-if&lt;/h3&gt; &lt;div&gt;msgBoolean01:true&lt;/div&gt; &lt;template v-if=\"msgBoolean01\"&gt; &lt;div&gt;(here is template v-if code block)if msgBoolean01 is true show this div&lt;/div&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;div&gt;(here is template v-else code block)if msgBoolean01 is false show this div&lt;/div&gt; &lt;/template&gt; &lt;br /&gt; &lt;div&gt;msgBoolean02:false&lt;/div&gt; &lt;template v-if=\"msgBoolean02\"&gt; &lt;div&gt;(here is template v-if code block)if msgBoolean02 is true show this div&lt;/div&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;div&gt;(here is template v-else code block)if msgBoolean02 is false show this div&lt;/div&gt; &lt;/template&gt; &lt;h3&gt;v-show&lt;/h3&gt; &lt;div&gt;msgBoolean01:true&lt;/div&gt; &lt;div v-show=\"msgBoolean01\"&gt;(here is v-show code block)if msgBoolean01 is true show this div&lt;/div&gt; &lt;div v-else&gt;(here is v-else code block)if msgBoolean01 is false show this div&lt;/div&gt; &lt;br /&gt; &lt;div&gt;msgBoolean01:false&lt;/div&gt; &lt;div v-show=\"msgBoolean02\"&gt;(here is v-show code block)if msgBoolean02 is true show this div&lt;/div&gt; &lt;div v-else&gt;(here is v-else code block)if msgBoolean02 is false show this div&lt;/div&gt; &lt;h3&gt;v-else（不需要表达式）&lt;/h3&gt; &lt;div&gt;限制：前一兄弟必须有v-if或者v-show&lt;/div&gt; &lt;div&gt;v-else的用法：上面三个例子中都有使用，请参考代码&lt;/div&gt; &lt;hr /&gt; &lt;h3&gt;v-for&lt;/h3&gt; &lt;div&gt;遍历数组：&lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"(index,item) in itemArrs\"&gt; &lt;!-- index代表的是当前item的下标，如果要取出下标的值则用&#123;&#123;$index&#125;&#125;即可 --&gt; index:&#123;&#123;$index&#125;&#125;, item:&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt;遍历对象key、value（不带下标index）&lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"(key,value) in itemObjs\"&gt; &lt;!-- key代表的是当前对象的属性名称，value代表的是当前对象的属性值 key取值的时候可以用&#123;&#123;$key&#125;&#125;，也可以使用&#123;&#123;key&#125;&#125; value取值的时候只能用&#123;&#123;value&#125;&#125; 建议：遍历对象不带index下标的时候同时用&#123;&#123;key&#125;&#125;和&#123;&#123;value&#125;&#125; --&gt; $key:&#123;&#123;$key&#125;&#125;,key:&#123;&#123;key&#125;&#125;, value:&#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt;遍历对象key、value（带下标index）&lt;/div&gt; &lt;ul&gt; &lt;li v-for=\"(index,key,value) in itemObjs\"&gt; &lt;!-- index代表的是当前属性的下标，key代表的是当前对象的属性名称，value代表的是当前对象的属性值 index取值的时候只能用&#123;&#123;$index&#125;&#125; key取值的时候只能用&#123;&#123;$key&#125;&#125; value取值的时候只能用&#123;&#123;value&#125;&#125; 建议：遍历对象不带index下标的时候同时用&#123;&#123;key&#125;&#125;和&#123;&#123;value&#125;&#125; --&gt; $index:&#123;&#123;$index&#125;&#125;, $key:&#123;&#123;$key&#125;&#125;, value:&#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;h3&gt;v-on&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(index,item) in itemArrs\"&gt; &lt;div class=\"item\" v-on:click=\"itemClick01\"&gt; &lt;span&gt;index:&#123;&#123;$index&#125;&#125;, item:&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;button v-on:click=\"itemClick02($index,item)\"&gt;内联语句（参数item参数）&lt;/button&gt; &lt;button v-on:click=\"itemClick03(item,$event)\"&gt;内联语句（参数event参数）&lt;/button&gt; &lt;button v-on:click.stop=\"itemClickStop(item)\"&gt;阻止冒泡&lt;/button&gt; &lt;a href=\"http://www.baidu.com\"&gt;跳转到百度&lt;/a&gt; &lt;a href=\"http://www.baidu.com\" v-on:click.prevent=\"itemClickPrevent()\"&gt;阻止a标签默认行为，不会跳转到百度&lt;/a&gt; &lt;input v-on:keyup.enter=\"keyUpEnter($event)\" placeholder=\"获取焦点后点击enter试试\" /&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;v-bind&lt;/h3&gt; &lt;div&gt; &lt;!-- 绑定 attribute --&gt; &lt;img v-bind:src=\"imageSrc\"&gt; &lt;!-- 缩写 --&gt; &lt;img :src=\"imageSrc\"&gt; &lt;!-- 绑定 class --&gt; &lt;div :class=\"&#123; red: isRed &#125;\"&gt;对象class&lt;/div&gt; &lt;div :class=\"[classA, classB]\"&gt;数组class&lt;/div&gt; &lt;div :class=\"[classA, &#123; classB: isB, classC: isC &#125;]\"&gt;对象数组class混用&lt;/div&gt; &lt;!-- 绑定 style --&gt; &lt;div :style=\"&#123; fontSize: size + 'px' &#125;\"&gt;对象style&lt;/div&gt; &lt;div :style=\"[styleObjectA, styleObjectB]\" style=\"background-color: ;\"&gt;数组style&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;body&gt; &lt;script&gt; var dr01 = new Vue(&#123; el: \"#dr01\", data: &#123; msgText: \"this is msgText!\", msgHtml: '&lt;span style=\"color:red;\"&gt;this is msgHtml&lt;/span&gt;', msgBoolean01: true, msgBoolean02: false, itemArrs: [\"item A\", \"item B\", \"item C\", \"item D\"], itemObjs: &#123; key01: \"this is value01\", key02: \"this is value02\", key03: \"this is value03\" &#125;, imageSrc: \"img/favicon.ico\", isRed: true, classA: \"class-a\", classB: \"class-b\", isB: true, isC: true, size: \"14\", styleObjectA: &#123; backgroundColor: \"#cccccc\" &#125;, styleObjectB: &#123; color: \"red\" &#125;, &#125;, methods: &#123; //方法处理器 itemClick01: function() &#123; console.log(\"u clicked the parent div\"); &#125;, //内联语句 itemClick02: function(index, item) &#123; console.log(\"current index: \" + index + \"; item: \" + item); &#125;, //event参数传递 itemClick03: function(item, event) &#123; console.log(\"current item: \" + item + \"; event target tagName: \" + event.target.tagName); &#125;, //阻止冒泡 itemClickStop: function(item) &#123; console.log(\"child button is clicked, please watch whether the parent div's log is priented!\") &#125;, //阻止默认的行为 itemClickPrevent: function() &#123; console.log(\"Prevent Default behaviour\"); &#125;, //点击 keyUpEnter: function(event) &#123; console.log(\"keyCode: \" + event.keyCode); &#125;, &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-if与v-else 根据条件判断结果渲染页面，也就是说只会渲染if和else里面的一个 12345678&lt;h3&gt;v-if&lt;/h3&gt;&lt;div&gt;msgBoolean01:true&lt;/div&gt;&lt;div v-if=\"msgBoolean01\"&gt;(here is v-if code block)if msgBoolean01 is true show this div&lt;/div&gt;&lt;div v-else&gt;(here is v-else code block)if msgBoolean01 is false show this div&lt;/div&gt;&lt;div&gt;msgBoolean01:false&lt;/div&gt;&lt;div v-if=\"msgBoolean02\"&gt;(here is v-if code block)if msgBoolean02 is true show this div&lt;/div&gt;&lt;div v-else&gt;(here is v-else code block)if msgBoolean02 is false show this div&lt;/div&gt; template v-if与template v-else 根据条件判断结果渲染页面，也就是说只会渲染if和else里面的一个 12345678910111213141516&lt;h3&gt;template v-if&lt;/h3&gt;&lt;div&gt;msgBoolean01:true&lt;/div&gt;&lt;template v-if=\"msgBoolean01\"&gt; &lt;div&gt;(here is template v-if code block)if msgBoolean01 is true show this div&lt;/div&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;div&gt;(here is template v-else code block)if msgBoolean01 is false show this div&lt;/div&gt;&lt;/template&gt;&lt;div&gt;msgBoolean02:false&lt;/div&gt;&lt;template v-if=\"msgBoolean02\"&gt; &lt;div&gt;(here is template v-if code block)if msgBoolean02 is true show this div&lt;/div&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;div&gt;(here is template v-else code block)if msgBoolean02 is false show this div&lt;/div&gt;&lt;/template&gt; v-text: 更新元素的textContent 在内部，大括号大括号Mustache大括号大括号插值也被编译为textNode的一个v-text指令，所以下面两个span渲染结果一致 123&lt;h3&gt;v-text&lt;/h3&gt;&lt;div v-text=\"msgText\"&gt;&lt;/div&gt;&lt;div&gt;&#123;&#123;msgText&#125;&#125;&lt;/div&gt; v-html：更新元素的 innerHTML 123&lt;h3&gt;v-html&lt;/h3&gt;&lt;div v-html=\"msgHtml\"&gt;&lt;/div&gt;&lt;div&gt;&#123;&#123;&#123;msgHtml&#125;&#125;&#125;&lt;/div&gt; 123&lt;h3&gt;v-html&lt;/h3&gt;&lt;div v-html=\"msgHtml\"&gt;&lt;/div&gt;&lt;div&gt;&#123;&#123;&#123;msgHtml&#125;&#125;&#125;&lt;/div&gt; v-show与v-else v-show的语句与v-if不同，不论判断条件结果如何，都会渲染整个html页面，只是将判断结果为false的那个节点加上style=”display:none;” 12345678&lt;h3&gt;v-show&lt;/h3&gt;&lt;div&gt;msgBoolean01:true&lt;/div&gt;&lt;div v-show=\"msgBoolean01\"&gt;(here is v-show code block)if msgBoolean01 is true show this div&lt;/div&gt;&lt;div v-else&gt;(here is v-else code block)if msgBoolean01 is false show this div&lt;/div&gt;&lt;div&gt;msgBoolean01:false&lt;/div&gt;&lt;div v-show=\"msgBoolean02\"&gt;(here is v-show code block)if msgBoolean02 is true show this div&lt;/div&gt;&lt;div v-else&gt;(here is v-else code block)if msgBoolean02 is false show this div&lt;/div&gt; v-else 不需要表达式，但是使用的前提条件是前面的兄弟节点必须是v-if或者v-show v-for 123456789101112131415161718192021222324252627282930313233&lt;div&gt;遍历数组：&lt;/div&gt;&lt;ul&gt; &lt;li v-for=\"(index,item) in itemArrs\"&gt; &lt;!-- index代表的是当前item的下标，如果要取出下标的值则用&#123;&#123;$index&#125;&#125;即可 --&gt; index:&#123;&#123;$index&#125;&#125;, item:&#123;&#123;item&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;div&gt;遍历对象key、value（不带下标index）&lt;/div&gt;&lt;ul&gt; &lt;li v-for=\"(key,value) in itemObjs\"&gt; &lt;!-- key代表的是当前对象的属性名称，value代表的是当前对象的属性值 key取值的时候可以用&#123;&#123;$key&#125;&#125;，也可以使用&#123;&#123;key&#125;&#125; value取值的时候只能用&#123;&#123;value&#125;&#125; 建议：遍历对象不带index下标的时候同时用&#123;&#123;key&#125;&#125;和&#123;&#123;value&#125;&#125; --&gt; $key:&#123;&#123;$key&#125;&#125;,key:&#123;&#123;key&#125;&#125;, value:&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;div&gt;遍历对象key、value（带下标index）&lt;/div&gt;&lt;ul&gt; &lt;li v-for=\"(index,key,value) in itemObjs\"&gt; &lt;!-- index代表的是当前属性的下标，key代表的是当前对象的属性名称，value代表的是当前对象的属性值 index取值的时候只能用&#123;&#123;$index&#125;&#125; key取值的时候只能用&#123;&#123;$key&#125;&#125; value取值的时候只能用&#123;&#123;value&#125;&#125; 建议：遍历对象不带index下标的时候同时用&#123;&#123;key&#125;&#125;和&#123;&#123;value&#125;&#125; --&gt; $index:&#123;&#123;$index&#125;&#125;, $key:&#123;&#123;$key&#125;&#125;, value:&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678itemArrs和itemObjs定义如下：itemArrs: [\"item A\", \"item B\", \"item C\", \"item D\"],itemObjs: &#123; key01: \"this is value01\", key02: \"this is value02\", key03: \"this is value03\"&#125; 结果: v-on: 绑定事件 1234567891011121314&lt;h3&gt;v-on&lt;/h3&gt;&lt;ul&gt; &lt;li v-for=\"(index,item) in itemArrs\"&gt; &lt;div class=\"item\" v-on:click=\"itemClick01\"&gt; &lt;span&gt;index:&#123;&#123;$index&#125;&#125;, item:&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;button v-on:click=\"itemClick02($index,item)\"&gt;内联语句（参数item参数）&lt;/button&gt; &lt;button v-on:click=\"itemClick03(item,$event)\"&gt;内联语句（参数event参数）&lt;/button&gt; &lt;button v-on:click.stop=\"itemClickStop(item)\"&gt;阻止冒泡&lt;/button&gt; &lt;a href=\"http://www.baidu.com\"&gt;跳转到百度&lt;/a&gt; &lt;a href=\"http://www.baidu.com\" v-on:click.prevent=\"itemClickPrevent()\"&gt;阻止a标签默认行为，不会跳转到百度&lt;/a&gt; &lt;input v-on:keyup.enter=\"keyUpEnter($event)\" /&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 定义在vue的methods 1234567891011121314151617181920212223242526methods: &#123; //方法处理器 itemClick01: function() &#123; console.log(\"u clicked the button\"); &#125;, //内联语句 itemClick02: function(index, item) &#123; console.log(\"current index: \" + index + \"; item: \" + item); &#125;, //event参数传递 itemClick03: function(item, event) &#123; console.log(\"current item: \" + item + \"; event target tagName: \" + event.target.tagName); &#125;, //阻止冒泡 itemClickStop: function(item) &#123; console.log(\"child button is clicked, please watch whether the parent div's log is priented!\") &#125;, //阻止默认的行为 itemClickPrevent: function() &#123; console.log(\"Prevent Default behaviour\"); &#125;, //点击 keyUpEnter: function(event) &#123; console.log(\"keyCode: \" + event.keyCode); &#125;,&#125; 简单介绍： 通过v-for来遍历items，div内的span标签是遍历的结果，后面紧跟了几个点击事件： div上的itemClick01是方法处理器 itemClick02是可以传递当前item值的内联语句 itemClick03是可以传递当前item的event事件的内联语句 itemClickStop是阻止冒泡，即相应完当前标签的事件后，阻止点击事件传递到上层div itemClickPrevent是阻止默认行为，a标签本身是跳转到其他页面，加上itemClickPrevent后阻止了打开新页面的行为 keyUpEnter是响应enter键的事件，但是前提是光标是当前input内 页面显示结果如下（定义了item的hover，当前鼠标悬停在第二个item上） 点击“内联语句（参数item参数）” 12current item: item B; event target tagName: BUTTONu clicked the parent div 点击“阻止冒泡” 1child button is clicked, please watch whether the parent div's log is priented! 点击“跳转到百度”：跳转到了百度页面。 点击“阻止a标签默认行为，不会跳转到百度”：没有响应 点击“input标签”： u clicked the parent div ，并点击enter键： keyCode: 13 v-bind 1234567891011121314151617&lt;h3&gt;v-bind&lt;/h3&gt;&lt;div&gt; &lt;!-- 绑定 attribute --&gt; &lt;img v-bind:src=\"imageSrc\"&gt; &lt;!-- 缩写 --&gt; &lt;img :src=\"imageSrc\"&gt; &lt;!-- 绑定 class --&gt; &lt;div :class=\"&#123; red: isRed &#125;\"&gt;对象class&lt;/div&gt; &lt;div :class=\"[classA, classB]\"&gt;数组class&lt;/div&gt; &lt;div :class=\"[classA, &#123; classB: isB, classC: isC &#125;]\"&gt;对象数组class混用&lt;/div&gt; &lt;!-- 绑定 style --&gt; &lt;div :style=\"&#123; fontSize: size + 'px' &#125;\"&gt;对象style&lt;/div&gt; &lt;div :style=\"[styleObjectA, styleObjectB]\"&gt;数组style&lt;/div&gt;&lt;/div&gt; 12345678910111213141516data中的定义imageSrc: \"img/favicon.ico\",isRed: true,classA: \"class-a\",classB: \"class-b\",isB: true,isC: true,size: \"14\",styleObjectA: &#123; backgroundColor: \"#cccccc\"&#125;,styleObjectB: &#123; color: \"red\"&#125; 展示结果： v-el 用法： 在其所有者Vue实例的$els对象上注册对DOM元素的引用，以便于访问。 1234&lt;span v-el:msg&gt;hello&lt;/span&gt;&lt;span v-el:other-msg&gt;world&lt;/span&gt;this.$els.msg.textContent // -&gt; \"hello\"this.$els.otherMsg.textContent // -&gt; \"world\" v-ref 注册对父项的子组件的引用，以便直接访问。不期待一个表达。必须提供一个参数作为注册的id。组件实例将可以在其父$refs对象上访问。 当与组件一起使用时v-for，注册的值将是包含与其绑定到的Array相对应的所有子组件实例的Array。如果数据源v-for是一个Object，则注册的值将是包含镜像源对象的键 - 实例对的Object。 123&lt;!--html--&gt;&lt;comp v-ref:child&gt;&lt;/comp&gt;&lt;comp v-ref:some-child&gt;&lt;/comp&gt; 1234//js// access from parent:this.$refs.childthis.$refs.someChild 和 v-for 使用 12&lt;!--html--&gt;&lt;comp v-ref:list v-for=\"item in list\"&gt;&lt;/comp&gt; 123//js// this will be an array in parentthis.$refs.list 在vue2的版本中，v-ref和v-el都被 ref指令代替 v-prev-pre标签内不解析 1&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt;","tags":[{"name":"vue指令，Vue.js","slug":"vue指令，Vue-js","permalink":"https://hudadahexiaolili.github.io/tags/vue指令，Vue-js/"}]},{"title":"Vue中的v-if和v-show","date":"2016-10-10T16:00:00.000Z","path":"2016/10/11/v-if和v-show/","text":"共同点 都是动态显示DOM元素 区别 手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐； 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留； 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。 注意点 如果v-show作用的元素，css文件中display:none，通过v-show进行设置不能显示该元素； 原因：v-show控制显隐，是通过js代码去修改元素的element style，如果value为false，设置display: none;如果value为true，设置display: &#39;&#39;；于是value为true时，只能将element style中的display效果清除，并不能覆盖css中的display效果；如下图所示，value=true时，v-show改变的是element.style，由于无效，显示效果由css文件中的display决定。 解决方法 使用v-show的话，在vue解析之前隐藏DOM的话，尽量在style属性里面设置display的值，不要在css文件中。 12&lt;ul v-touch:tap=\"message=2\" style=\"display: none\" v-show=\"show\"&gt;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://hudadahexiaolili.github.io/tags/Vue-js/"},{"name":"v-if","slug":"v-if","permalink":"https://hudadahexiaolili.github.io/tags/v-if/"},{"name":"v-show","slug":"v-show","permalink":"https://hudadahexiaolili.github.io/tags/v-show/"}]},{"title":"Windows不能在本地计算机启动Apache","date":"2016-10-01T16:00:00.000Z","path":"2016/10/02/apache不能正常启动的解决方法/","text":"遇到的问题 在使用集成环境 WampServer 的时候，发现其图标为黄色， 却还显示 Server Online。 而且在本地计算机不能启动 Apache 服务。 解决 1.切换到你的apache的bin目录下，按住shift和鼠标右键，打开命令窗口，执行httpd.exe，看有什么提示。 2. 根据错误提示，修改相应的信息。比如我的是ServerRoot must be a valid directory,就是说安装目录不能有中文，因此要改安装目录的名称全为英文。 3. 修改问题之后，window + R 输入 services.msc，找到 wampapache 右键管理，重新启动即可。","tags":[{"name":"Apache","slug":"Apache","permalink":"https://hudadahexiaolili.github.io/tags/Apache/"}]},{"title":"a标签点击跳转页面后怎么给当前点击的a标签添加样式","date":"2016-07-22T16:00:00.000Z","path":"2016/07/23/a/","text":"在写项目的时候碰到一个问题:a标签点击跳转页面后,给当前点击的a标签添加的样式不会显示。怎么解决呢？ 问题描述 原本点击仪表盘等标签后，该标签的背景颜色会发生改变，可点击之后，a标签会发生跳转，该标签的背景色也不会再显示。 XML/HTML code： 123456789101112131415161718192021222324252627282930313233343536&lt;aside class='aside'&gt; &lt;div class='profile'&gt; &lt;div class='avatar img-circle'&gt; &lt;img src='./uploads/avatar.jpg' alt='您的头像'&gt; &lt;/div&gt; &lt;h4&gt;&lt;span &gt;胡大大&lt;/span&gt;&lt;/h4&gt; &lt;/div&gt; &lt;div class='navs'&gt; &lt;ul&gt; &lt;li&gt;&lt;a href='dashboard.html'&gt;&lt;i class='fa fa-bar-chart '&gt;&lt;/i&gt;仪表盘&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href='#' &gt;&lt;i class='fa fa fa-user'&gt;&lt;/i&gt;用户管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href='./index.html'&gt;&lt;i class='fa fa-mortar-board'&gt;&lt;/i&gt;讲师管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href='#' class='course_click'&gt; &lt;i class='fa fa-book'&gt;&lt;/i&gt;课程管理&lt;i class='arrow fa fa-angle-right pull-right'&gt;&lt;/i&gt; &lt;/a&gt; &lt;ul class='course ' style='display:none'&gt; &lt;li&gt;&lt;a href='#'&gt;课程添加&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href='#'&gt;课程列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href='#'&gt;课程分类&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href='#'&gt;课程专题&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href='#'&gt;&lt;i class='fa fa-link'&gt;&lt;/i&gt;广告管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href='#' class='course_click'&gt; &lt;i class='fa fa-cog fa-spin'&gt;&lt;/i&gt;系统设置&lt;i class='arrow fa fa-angle-right pull-right'&gt;&lt;/i&gt; &lt;/a&gt; &lt;ul class='course ' style='display:none'&gt; &lt;li&gt;&lt;a href='#'&gt;网站设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href='#'&gt;权限管理&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/aside&gt; 那么怎么解决呢？ 一般使用以下几种方法: 用cookie记录这个打开的序列号，然后页面在跳转的时候再读出来。 循环a的链接，然后与location.href去比对，如果相同，或包含有同样字符串序列，则添加className. 给每个页面写一个页面的id值，然后每次判断，有值则addClass 12给url后面加一个参数，比如a.php？1，取url后面的1，判断对应的是第一个导航添加一个选中的class实际网站中，通常用php做页面判断，判断为是，则相应的a解析出来有active样式，判断为否则a中的active样式不解析 个人比较推荐第二种写法: 1234567891011121314151617181920212223242526272829303132// 方法1$(document).ready(function () &#123; var url = window.location.href; $('.navs li a').each(function () &#123; var userUrl = returnFileName($(this).attr('href')) + returnUrl($(this).attr('href')); var windowUrl = returnFileName(url) + returnUrl(url); if (userUrl == windowUrl ) &#123; $(this).addClass('active'); &#125; &#125;); //以下为截取url的方法 function returnUrl(href) &#123; var number = href.lastIndexOf(\"/\"); return href.substring(number + 1); &#125; function returnFileName(href) &#123; var number1 = href.lastIndexOf(\"/\"); var number2 = href.substring(0, number1).lastIndexOf(\"/\"); return href.substring(number1, number2 + 1); &#125;&#125;)// 推荐这一种写法$(document).ready(function () &#123; $('.navs li a').each(function () &#123; if ($($(this))[0].href == String(window.location)) $(this).addClass('active').attr('href', 'javascript:void(0);'); &#125;); &#125;)","tags":[{"name":"a标签跳转","slug":"a标签跳转","permalink":"https://hudadahexiaolili.github.io/tags/a标签跳转/"}]},{"title":"js获取url传递参数,js获取url？号后面的参数","date":"2016-07-22T16:00:00.000Z","path":"2016/07/23/截取url/","text":"我们在写项目的时候往往会需要获取 url 或截取 url ? 后的参数，为了方便，总结了以下几种方法: 方法一: 利用正则表达式 123456function getQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null; &#125; 方法二: 获取 url 中 “?” 符号后的字串 12345678910111213function GetRequest() &#123; var url = location.search; //获取url中\"?\"符后的字串 var theRequest = new Object(); if (url.indexOf(\"?\") != -1) &#123; var str = url.substr(1); strs = str.split(\"&amp;\"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split(\"=\")[0]]=unescape(strs[i].split(\"=\")[1]); &#125; &#125; return theRequest; &#125; 方法三: 获取指定的 url 参数值 123456789101112131415/** * 获取指定的URL参数值 * URL:http://.../index?name=hudada * 参数：paramName URL参数 * 调用方法:getParam(\"name\") * 返回值:hudada */ function getParam(paramName) &#123; paramValue = \"\", isFound = !1; if (this.location.search.indexOf(\"?\") == 0 &amp;&amp; this.location.search.indexOf(\"=\") &gt; 1) &#123; arrSource = unescape(this.location.search).substring(1, this.location.search.length).split(\"&amp;\"), i = 0; while (i &lt; arrSource.length &amp;&amp; !isFound) arrSource[i].indexOf(\"=\") &gt; 0 &amp;&amp; arrSource[i].split(\"=\")[0].toLowerCase() == paramName.toLowerCase() &amp;&amp; (paramValue = arrSource[i].split(\"=\")[1], isFound = !0), i++ &#125; return paramValue == \"\" &amp;&amp; (paramValue = null), paramValue &#125; 其它参数介绍 1234567891011121314151617181920//设置或获取对象指定的文件名或路径。alert(window.location.pathname);//设置或获取整个 URL 为字符串。alert(window.location.href);//设置或获取与 URL 关联的端口号码。alert(window.location.port);//设置或获取 URL 的协议部分。alert(window.location.protocol);//设置或获取 href 属性中在井号“#”后面的分段。alert(window.location.hash);//设置或获取 location 或 URL 的 hostname 和 port 号码。alert(window.location.host);//设置或获取 href 属性中跟在问号后面的部分。alert(window.location.search);","tags":[{"name":"截取url","slug":"截取url","permalink":"https://hudadahexiaolili.github.io/tags/截取url/"}]},{"title":"快速理解JavaScript中apply()和call()的用法和用途","date":"2016-05-01T16:00:00.000Z","path":"2016/05/02/apply-call-bind/","text":"接触JavaScript 的函数 apply 和 call 时，理解的非常模糊，网上资料枚不胜举，但大多晦涩难懂，整理了一下不理解的地方。 在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数中的this指向。 call、apply、bind方法的共同点和区别 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 定义和语法call 语法: call([thisObj[,arg1[, arg2[, [,.argN]]]]]) 定义: 劫持另外一个对象的方法，继承另外一个对象的属性.(调用一个对象的一个方法，以另一个对象替换当前对象。) 说明: call 方法可以用来代替另一个对象调用一个方法 call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象. 取值: 不传，或者传null,undefined， 函数中的this指向window对象 传递另一个函数的函数名，函数中的this指向这个函数的引用 传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean 传递一个对象，函数中的this指向这个对象 举例: 12345678910111213141516function a()&#123; console.log(this); //输出函数a中的this对象&#125; function b()&#123;&#125; var c=&#123;name:\"call\"&#125;; //定义对象c a.call(); //windowa.call(null); //windowa.call(undefined); //windowa.call(1); //Numbera.call(''); //Stringa.call(true); //Booleana.call(b); //function b()&#123;&#125;a.call(c); //Object 对上面的例子觉得还是晦涩，让我们在来看一个例子:123456789101112// ==&gt;例1function class1()&#123; this.name=function()&#123; console.log(\"我是class1内的方法\"); &#125; &#125; function class2()&#123; class1.call(this); //此行代码执行后，当前的this指向了class1（也可以说class2继承了class1） &#125; var f=new class2(); f.name(); //调用的是class1内的方法，将class1的name方法交给class2使用 123456789101112//常用例子 1function eat(x,y)&#123; console.log(x+y); &#125; function drink(x,y)&#123; console.log(x-y); &#125; eat.call(drink,3,2);//输出：5//这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2) ，所以运行结果为：console.log(5);//注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 12345678910111213141516171819//常用例子2function Animal()&#123; this.name=\"animal\"; this.showName=function()&#123; console.log(this.name); &#125; &#125; function Dog()&#123; this.name=\"dog\"; &#125; var animal=new Animal(); var dog=new Dog(); animal.showName.call(dog);//输出：dog//在上面的代码中，我们可以看到Dog里并没有showName方法，那为什么（this.name）的值是dog呢？//关键就在于最后一段代码（animal.showName.call(dog)），意思是把animal的方法放到dog上执行，也可以说，把animal 的showName()方法放到 dog上来执行，所以this.name 应该是 dog。 123456789101112131415//常用例子3 (继承)function Animal(name)&#123; this.name=name; this.showName=function()&#123; console.log(this.name); &#125; &#125; function Dog(name)&#123; Animal.call(this,name); &#125; var dog=new Dog(\"Crazy dog\"); dog.showName();//输出：Crazy dog//Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么Dog就能直接调用Animal的所有属性和方法。 apply 语法: apply([thisObj[,argArray]]) 定义: 应用某一对象的一个方法，用另一个对象替换当前对象。 说明: 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 call 和 apply 的区别对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。1234567891011121314151617function class1(args1,args2)&#123; this.name=function()&#123; console.log(args,args); &#125; &#125; function class2()&#123; var args1=\"1\"; var args2=\"2\"; class1.call(this,args1,args2); /*或*/ class1.apply(this,[args1,args2]);&#125;var c=new class2(); c.name();输出：1 2 call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 既然两者功能一样，那该用哪个呢？ 在JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call ；而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。 bind bind是在EcmaScript5中扩展的方法（IE6,7,8不支持） bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。 MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 注意：bind方法的返回值是函数123456789101112131415var bar=function()&#123; console.log(this.x); &#125;var foo=&#123; x:3 &#125; bar(); bar.bind(foo)(); /*或*/var func=bar.bind(foo); func();//输出：//undefined//3 深入理解 apply call bind希望通过这篇笔记，更加清晰的提升对三者的理解，并列出一些关于它们的妙用加深记忆. apply、call在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。先看一个例子：12345678910111213function fruits() &#123;&#125; fruits.prototype = &#123; color: \"red\", say: function() &#123; console.log(\"My color is \" + this.color); &#125;&#125; var apple = new fruits;apple.say(); //My color is red //但是如果我们有一个对象banana= &#123;color : \"yellow\"&#125; , //我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法： 1234567banana = &#123; color: \"yellow\"&#125;apple.say.call(banana); //My color is yellowapple.say.apply(banana); //My color is yellow//所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本例子中banana没有say方法），//但是其他的有（本例子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。 apply、call 的区别 对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。例如，有一个函数定义如下： 123var func = function(arg1, arg2) &#123; &#125;; 就可以通过如下方式来调用：12func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]) 其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。 为了巩固加深记忆，下面列举一些常用用法： 1.数组之间追加 1234var array1 = [12 , \"foo\" , &#123;name \"Joe\"&#125; , -2458]; var array2 = [\"Doe\" , 555 , 100]; Array.prototype.push.apply(array1, array2); /* array1 值为 [12 , \"foo\" , &#123;name \"Joe\"&#125; , -2458 , \"Doe\" , 555 , 100] */ 获取数组中的最大值和最小值 123var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458 maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458 number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。 3、验证是否是数组（前提是toString()方法没有被重写过） 123functionisArray(obj)&#123; return Object.prototype.toString.call(obj) === '[object Array]' ;&#125; 4.类（伪）数组使用数组方法 1var domNodes = Array.prototype.slice.call(document.getElementsByTagName(\"*\")); Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。 但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。 深入理解运用 apply 、call 定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是： 12345function log(msg) &#123; console.log(msg);&#125;log(1); //1log(1,2); //1 上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里传入多少个参数是不确定的，所以使用apply是最好的，方法如下： 12345function log()&#123; console.log.apply(console, arguments);&#125;;log(1); //1log(1,2); //1 2 接下来的要求是给每一个 log 消息添加一个”(app)”的前辍，比如： 1log(\"hello world\"); //(app)hello world 该怎么做比较优雅呢?这个时候需要想到arguments参数是个伪数组，通过 Array.prototype.slice.call 转化为标准数组，再使用数组方法unshift，像这样：123456function log()&#123; var args = Array.prototype.slice.call(arguments); args.unshift('(app)'); console.log.apply(console, args);&#125;; bind说完了 apply 和 call ，再来说说bind。bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。 MDN的解释是：bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 _this , that , self 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样： 12345678910var foo = &#123; bar : 1, eventBind: function()&#123; var _this = this; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(_this.bar); //1 &#125;); &#125;&#125; 由于 Javascript 特有的机制，上下文环境在 eventBind:function(){ } 过渡到 $(‘.someClass’).on(‘click’,function(event) { }) 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。当然使用 bind() 可以更加优雅的解决这个问题： 123456789var foo = &#123; bar : 1, eventBind: function()&#123; $('.someClass').on('click',function(event) &#123; /* Act on the event */ console.log(this.bar); //1 &#125;.bind(this)); &#125;&#125; 在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子： 123456789var bar = function()&#123;console.log(this.x);&#125;var foo = &#123;x:3&#125;bar(); // undefinedvar func = bar.bind(foo);func(); // 3 这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。 有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样： 1234567891011121314151617var bar = function()&#123; console.log(this.x);&#125;var foo = &#123; x:3&#125;var sed = &#123; x:4&#125;var func = bar.bind(foo).bind(sed);func(); //? var fiv = &#123; x:5&#125;var func = bar.bind(foo).bind(sed).bind(fiv);func(); //? 答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。 apply、call、bind比较 那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子： 12345678910111213var obj = &#123; x: 81,&#125;; var foo = &#123; getX: function() &#123; return this.x; &#125;&#125; console.log(foo.getX.bind(obj)()); //81console.log(foo.getX.call(obj)); //81console.log(foo.getX.apply(obj)); //81 三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。 也就是说，区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。 总结 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。","tags":[{"name":"apply","slug":"apply","permalink":"https://hudadahexiaolili.github.io/tags/apply/"},{"name":"bind","slug":"bind","permalink":"https://hudadahexiaolili.github.io/tags/bind/"},{"name":"call","slug":"call","permalink":"https://hudadahexiaolili.github.io/tags/call/"}]},{"title":"利用 github 搭建静态网站","date":"2016-04-07T16:00:00.000Z","path":"2016/04/08/static-website/","text":"一直用 github 写博客文章，着实少了点乐趣，其实我们也可以利用 github 部署网站，话不多说，整理笔记如下: 初学者 链接：https://pan.baidu.com/s/1cevTGa 密码：c332 1. 登录个人界面 注册 GitHub 账号，完善用户信息后，进入个人界面。 2. 点击 Repositories Repositories 在 GitHub 上表示的是仓库，在 GitHub 上每个项目都存放在仓库里，一个仓库保存一个项目. 3. 点击 New 按钮 4. 创建仓库 根据图中的提示填写信息，信息填写完成后单击 Create respository 按钮创建仓库。 5. 点击 Settings 创建好仓库后,会自动跳转到下图所示的界面，在界面中单击Settings. 6. 创建网站主题 进入设置界面后一直往下，找到 GitHub Page ,并且单击GitHub Page模块中的 Choose a theme 按钮创建一个网站的主题。 7. 选择 Cayman 主题,然后点击 select theme 按钮 8. 点击 Commit changes 按钮 选择主题后，自动跳转页面，页面往下拉，找到 Commit changes,点击按钮。 9. 点击 Settings 按钮 单击Commit changes按钮后会自动跳转到我们创建的仓库界面，里面包含了仓库的各种信息，其中master表示这个仓库位于master分之上，进入界面后单击Settings按钮。 10. 在Settings界面中往下滑，滑到GitHub Page模块，可以看到GitHub Page模块中多了一个网址 11. 打开网址，查看效果 在浏览器中打开网址后，可以看到网页上呈现出的内容就是我们刚刚创建的主题为Cayman的网页。 12. 回到仓库界面 回到GitHub上,并且打开我们刚刚创建的那个仓库，仓库里的文件就是刚刚在浏览器中显示的内容，接下来要做的事情就是修改仓库里的文件，单击Clone or download按钮。 13. 单击复制到剪切板按钮，复制仓库的url 14. 创建一个文件夹 在电脑中创建一个文件夹(比如E盘，自己决定)，用于保存从Github中克隆下来的仓库，我建的文件夹叫做Blog-love-static-website(好长，哈哈哈)，进入此文件夹下。shift + 鼠标右键 打开命令窗口。 15. 克隆项目 在命令行中执行git clone https://github.com/HudadaHexiaolili/love-static-website.git命令 其中git clone 表示要克隆一个项目，后面的https://github.com/HudadaHexiaolili/love-static-website.git表示项目地址，该地址是由第13步操作获得的，当在最后一行出现了100%表示，远程仓库已经成功的克隆到了本地 16. 查看文件 打开创建的文件，发现多了个 love-static-website 文件，该文件是刚刚在 GitHub 中创建的仓库 17. 打开文件，并且将需要上传到GitHub上的网站添加到该文件中 注意 你的首页文件名必须为 index.html 18. 执行下面命令 打开命令行，并且进入love-static-website文件夹下 git add -A //将文件添加到缓存区 git commit -m &quot;first commit.&quot; //将文件提交到git中 git push origin master //将文件push到GitHub上的master分支上 当出现上图所示的提示信息时，表示网站已经成功的提交到了GitHub上 19. 回到Github上的boyaa仓库，可以看到文件已经全部提交上来了 查看效果 激动人心的一刻来了，再次打开位于Settings下，GitHub Page模块中的网址，可以看到网页变成了我们修改后的页面网站的网站：https://hudadahexiaolili.github.io/love-static-website/通过观察网址可知，网址的格式为 https:// + GitHub的用户名 + .github.io/ + 仓库的名称 小结方法很简单，还可以利用这种方法在github上创建自己的简历，性价比很高。 怎么写简历中的自我评价？如何做一份优秀的简历？ 当然也可以通过在线简历制作制作自己的简历，不过不如自己写的开心好像。","tags":[{"name":"github","slug":"github","permalink":"https://hudadahexiaolili.github.io/tags/github/"},{"name":"静态网站","slug":"静态网站","permalink":"https://hudadahexiaolili.github.io/tags/静态网站/"},{"name":"程序员表白","slug":"程序员表白","permalink":"https://hudadahexiaolili.github.io/tags/程序员表白/"}]},{"title":"使用canvas绘制饼形图","date":"2016-04-01T16:00:00.000Z","path":"2016/04/02/canvas绘制饼形图/","text":"绘制任意数据的简单饼形图 准备工作12345678910// ===&gt; 步骤 1 // 创建canvas标签，该标签用来展示图像var canvas = document.createElement(\"canvas\");//canvas的宽高不要使用 CSS 来设置，会有拉伸问题，应该直接使用属性设置canvas.width = 600;canvas.height = 400;canvas.style.border = '1px dashed red';document.body.appendChild(canvas);//获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象.var context = canvas.getContext('2d'); 生成随机函数1234567891011121314151617181920212223242526272829303132333435// ===&gt; 步骤 2 //随机函数var random = (function () &#123; //传入参数为两个，表示生成的数的个数在 min 和 max 之间取值 function randomWithTwoParam( min , max ) &#123; return Math.floor( ( max - min ) * Math.random() ) + min; &#125; // 传入的参数为 1 个,表示生成的数的个数在 0 -max 之间取值 function randomWithOneParam( max ) &#123; return randomWithTwoParam( 0, max ); &#125; function random( min , max ) &#123; if ( min === undefined ) &#123; return Math.random(); &#125; else if ( max === undefined ) &#123; return randomWithOneParam( min ); &#125; else &#123; return randomWithTwoParam( min , max ); &#125; &#125; return random;&#125;)();//颜色var colors = 'blueviolet,dodgerblue,orangered,limegreen,yellow,aqua,deeppink'.split( ',' );//colors.length = 7;//随机生成5-7个数var count = random ( 5, colors.length);//生成数字数组var numbers = [];while ( numbers.length &lt;= count ) &#123; numbers.push( random (100) );&#125; 求生成的随机角度123456789101112// ===&gt; 步骤 3//求生成数字的总和var sum = 0;for( var i = 0; i &lt; numbers.length; i++ ) &#123; sum += numbers[ i ];&#125;//分析://生成的随机角数字 / 所对应的饼状图角度 = 生成数的总和 / (2*Math.PI)var numObjs = numbers.map( v =&gt; (&#123; value: v, angle: v * 2 * (Math.PI) / sum&#125;)); 绘制饼状图12345678910//===&gt; 步骤 4//循环绘制饼状图var startAngel = -(Math.PI/2);numObjs.forEach( function ( v , i ) &#123; context.beginPath(); context.fillStyle = colors[ i ]; context.moveTo( 300, 200 ); context.arc( 300, 200, 100, startAngel, startAngel += v.angle ); context.fill();&#125;); 整合代码代码整合: 将上述代码依次整合在一个script标签中,代码结束. 小结饼状图只实现了大体功能,并未将数据添加到饼状图上，细节工作有待完善。","tags":[{"name":"饼形图","slug":"饼形图","permalink":"https://hudadahexiaolili.github.io/tags/饼形图/"}]},{"title":"使用canvas绘制 折线图","date":"2016-03-31T16:00:00.000Z","path":"2016/04/01/canvas绘制折线图/","text":"随机生成将数据，并将其以折线图的方式显示出来 绘制坐标系 基本绘制:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//具体实现代码 // ===&gt; 步骤 1. // 创建canvas标签，该标签用来展示图像 var canvas = document.createElement(\"canvas\"); //canvas的宽高不要使用 CSS 来设置，会有拉伸问题，应该直接使用属性设置 canvas.width = 600; canvas.height = 400; canvas.style.border = '1px dashed red'; document.body.appendChild(canvas); //获得绘图工具, 该工具是 CanvasRenderingContext2D 类型的对象. var context = canvas.getContext('2d'); // 不要硬编码 // 考虑是应该有什么参量? // 常规意义上是给 上下左右边距 var paddingleft = 50, paddingright = 50, paddingtop = 50, paddingbottom = 50; //箭头的宽度、高度 var arrowWidth = 10, arrowHeight = 20; //原点坐标 var ox = paddingleft, oy = canvas.height - paddingbottom; // 绘制坐标轴 //设置开始绘图的位置为 Y轴顶点处 //开始沿Y轴负方向、原点、X轴正方向依次绘制直线 context.moveTo( ox, paddingtop ); context.lineTo( ox, oy ); context.lineTo( canvas.width - paddingright, oy ); context.stroke();//描边绘制 // 绘制箭头 //开启新的绘制 context.beginPath(); //绘制Y轴箭头 context.moveTo( ox - arrowWidth / 2, paddingtop + arrowHeight ); context.lineTo( ox, paddingtop ); context.lineTo( ox + arrowWidth / 2, paddingtop + arrowHeight ); context.lineTo( ox, paddingtop + arrowHeight * 2 / 3 ); //填充绘制 context.fill(); //开启新的绘制 context.beginPath(); //绘制X轴箭头 context.moveTo( canvas.width - paddingright - arrowHeight, oy - arrowWidth / 2 ); context.lineTo( canvas.width - paddingright, oy ); context.lineTo( canvas.width - paddingright - arrowHeight, oy + arrowWidth / 2 ); context.lineTo( canvas.width - paddingright - arrowHeight * 2 / 3, oy ); //填充绘制 context.fill(); 效果示意图12&lt;script&gt; code &lt;/script&gt;将上述代码替换 code .在将&lt;script&gt;加入到&lt;body&gt;后.浏览器效果如下图: 绘制坐标系上的单点( 理解过渡 可忽略)绘制完坐标系，尝试在其基础上绘制单点12345678910111213141516171819202122//举个例子，绘制点(100,100)// 步骤：// 1.先计算 对应的坐标 在 坐标系 中的实际坐标// 2.拿到原点坐标var ox = paddingleft, oy = canvas.height - paddingbottom;// 3.实际坐标var x = ox + 100, y = oy - 100;// 4.绘制点// 注意: 绘制的时候起始点从坐标点向上,向左移动 2 个像素 context.beginPath(); context.moveTo( x - 2, y - 2 ); context.lineTo( x + 2, y - 2 ); context.lineTo( x + 2, y + 2 ); context.lineTo( x - 2, y + 2 ); context.closePath(); //秒变颜色 context.strokeStyle = 'blue'; //描边绘制 context.stroke(); 单点绘制效果图: 多点绘制(数字随机生成)随机生成函数123456789101112131415161718192021222324252627282930313233343536// ===&gt; 步骤 2. 准备随机函数var random =( function () &#123; //传入参数为两个，表示生成的数的个数在 min 和 max 之间取值 function randomWithTwoParam( min , max ) &#123; return Math.floor( ( max - min ) * Math.random() ) + min; &#125; // 传入的参数为 1 个,表示生成的数的个数在 0 -max 之间取值 function randomWithOneParam( max ) &#123; return randomWithTwoParam( 0, max ); &#125; function random ( min, max ) &#123; if ( min === undefined ) &#123;//没有传参 return Math.random(); &#125; else if ( max === undefined ) &#123;//只传了min return randomWithOneParam( min ); &#125; else &#123;//传了min 和 max 俩参数 return randomWithTwoParam( min, max ); &#125; &#125; return random;&#125;)();//随机生成几个点(范围在传入的值之间，这里传入了 5 和 20,表示个数在5-20之间)var count = random( 5, 20 );var points = [];var x;while ( points.length &lt; count ) &#123; //注意 x 不允许重复 x = random( 1000 );//生成一个0-1000的随机数X if( points.every( pt =&gt; pt.x != x) ) &#123; //没有这个 x points.push(&#123; x: x, y: random( 1000 )//生成一个0-1000的随机数Y &#125;); &#125;&#125; console.table( points ); 便会得到下面的图: 计算最值求比例123456789101112131415// ===&gt; 步骤 3.求 X 和 Y 的最大值var maxX = Math.max.apply( null, points.map( pt =&gt; pt.x ) ), maxY = Math.max.apply( null, points.map( pt =&gt; pt.y ) );// 对数组按照 x 的大小排序points.sort( ( a, b ) =&gt; a.x - b.x );// 计算比例// 思考: 我们的目的是什么?// 我们的目的是计算在画布中的绘制坐标// 绘制坐标 : 随机坐标 == 坐标系的宽高 : 最大的xy// 比例 ( rate ) = 坐标系的宽高 / 最大值var rateX = ( canvas.width - paddingLeft - paddingRight ) / maxX, rateY = ( canvas.height - paddingTop - paddingBottom ) / maxY; 123console.table( points );console.log( 'maxX = ' + maxX + ', maxY = ' + maxY );//在控制台输出得到下面的图 计算绘制坐标1234567// ===&gt; 步骤 4.计算要绘制的坐标var newpoints = points.map( pt =&gt; (&#123; x: pt.x, y: pt.y, drawX: pt.x * rateX, drawY: pt.y * rateY &#125;) ); 12console.table( newpoints );//输出得到下图所示： 连线绘制点1234567891011121314151617181920212223242526272829303132// ===&gt; 步骤 5.连线绘制点context.beginPath();context.fillStyle = 'red';newpoints.forEach(function (newpt) &#123; //让 随机点 在坐标范围内显示 var x = ox + newpt.drawX, y = oy - newpt.drawY; //生成多个 随机点 context.moveTo(x - ptWidth / 2, y - ptWidth / 2); context.lineTo(x + ptWidth / 2, y - ptWidth / 2); context.lineTo(x + ptWidth / 2, y + ptWidth / 2); context.lineTo(x - ptWidth / 2, y + ptWidth / 2); context.closePath();&#125;);//填充绘制context.fill();// 连线context.beginPath();context.strokeStyle = 'red';//让折线拐角处不出现尖角context.lineJoin = 'round';context.lineWidth = 1;newpoints.forEach(function (newpt) &#123; var x = ox + newpt.drawX, y = oy - newpt.drawY; context.lineTo(x, y);&#125;);//描边连线context.stroke(); 最终效果图代码整合: 将上述代码依次整合在一个script标签中,代码结束. 小结1简单完成了，随机数生成折线图的功能，可样式不够美观，没有在折线处添加数据，还有很多不足的地方，以后会完善。","tags":[{"name":"折线图","slug":"折线图","permalink":"https://hudadahexiaolili.github.io/tags/折线图/"}]},{"title":"Vue中的AJAX请求","date":"2016-03-20T16:00:00.000Z","path":"2016/03/21/vue的ajax/","text":"Vue中的AJAX请求 1Vue可以借助于vue-resource来实现AJAX请求 http请求报文 123456浏览器与服务器数据交互是遵循http协议的，当浏览器要访问服务器的时候，浏览器需要将相关请求数据提交给服务器（例如：浏览器信息，url地址，参数等），通常是通过请求报文来提交的请求报文的格式分为： 1、请求报文行 2、请求报文头 3、请求报文体 http响应报文 123456当浏览器请求服务器的时候，服务器需要将数据返回给浏览器，这种数据是通过响应报文响应回浏览器的 响应报文的格式分为： 1、响应报文行 2、响应报文头 3、响应报文体 请求报文和响应报文配图 3.1 vue-resource1Vue与后台Api进行交互通常是利用vue-resource来实现的，本质上vue-resource是通过http来完成AJAX请求响应的 vue-resource GitHub 地址：https://github.com/pagekit/vue-resource vue-resource Http请求api参考（主要看这个）：https://github.com/pagekit/vue-resource/blob/master/docs/http.md vue结合vue-resource写法步骤 1234567891011121、通过 https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js 下载到vue-resource文件2、在html页面中通过script标签导入vue-resource.min.js 文件后，就会自动的在Vue对象实例上初始化 $http3、使用// 全局Vue对象写法 Vue.http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback); Vue.http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback);// 在Vue对象中的写法 this.$http.get(&apos;/someUrl&apos;, [options]).then(successCallback, errorCallback); this.$http.post(&apos;/someUrl&apos;, [body], [options]).then(successCallback, errorCallback); vue-resource get请求 12345678910写法格式： this.$http.get(&apos;请求的url&apos;, [可选参数对象，使用&#123;&#125;传参]).then(成功回调函数, 失败回调函数); 成功回调函数参数对象主要属性说明：1、url ： 请求的原始url2、body： 响应报文体中的数据（我们通常用这个属性获取服务器返回的数据）3、其他属性请看文档举例： this.$http.get(&apos;http://vuecms.ittun.com/api/getlunbo?id=1&apos;).then(function(res)&#123;console.log(res.body)&#125;, function(err)&#123;//err是异常数据&#125;); 实例123456789101112131415161718192021222324252627&lt;div id='#app'&gt; &lt;button @click='getData'&gt; get请求 &lt;button&gt; &#123;&#123; msg | json &#125;&#125;&lt;/div&gt;&lt;script&gt;//创建根实例var vm = new Vue(&#123; //挂载 el:'#app', data:&#123; msg:[] &#125;, methods:&#123; getData:function()&#123; //发起请求 var url = 'http://182.254.146.100:8899/api/getnewslist'; this.$http.get(url).then( function(response)&#123; this.msg = response.body.message &#125; ) &#125; &#125;&#125;)&lt;/script&gt; vue-resource post请求 12345678910111213141516写法格式： this.$http.post(&apos;请求的url&apos;,[可选参数请求报文体对象body,使用&#123;&#125;传参], [可选参数对象，使用&#123;&#125;传参]).then(成功回调函数, 失败回调函数); 成功回调函数参数对象主要属性说明：1、url ： 请求的原始url2、body： 响应报文体中的数据（我们通常用这个属性获取服务器返回的数据）3、其他属性请看文档注意点：$http.post()方法中的第二个参数固定写成：&#123;emulateJSON:true&#125;,否则可能造成服务器无法接收到请求报文体中的参数值举例： this.$http.post(&apos;http://vuecms.ittun.com/api/adddata?id=1&apos; //请求的url ,&#123;content:&apos;hello&apos;&#125; //请求报文体中传入的参数对象，多个使用逗号分隔 ,&#123;emulateJSON:true&#125; //固定写法，保证服务器可以获取到请求报文体参数值 ).then(function(res)&#123;console.log(res.body)&#125;, function(err)&#123;//err是异常数据&#125;); 123456789101112131415161718&lt;div id=&apos;#app&apos;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:&apos;#app&apos;, methods:&#123; postData:function()&#123; var url = &apos;http://182.254.146.100:8899/api/postcomment/14&apos;; this.$http.post(url,&#123;content:&apos;xxxxxxx&apos;&#125;,&#123;emulateJSON:true&#125;) .then(function(resopnse)&#123; alert(&apos;success&apos;) &#125;) &#125; &#125; &#125;)&lt;/script&gt; vue-resource jsonp请求 12345678910111213jsonp请求主要用来解决ajax跨域请求问题，使用jsonp实现跨域首先要保证服务器api支持jsonp请求的格式写法格式： this.$http.jsonp(&apos;请求的url&apos;, [可选参数对象，使用&#123;&#125;传参]).then(成功回调函数, 失败回调函数); 成功回调函数参数对象主要属性说明：1、url ： 请求的原始url2、body： 响应报文体中的数据（我们通常用这个属性获取服务器返回的数据）3、其他属性请看文档举例： this.$http.jsonp(&apos;http://vuecms.ittun.com/api/getlunbo?id=1&apos;).then(function(res)&#123;console.log(res.body)&#125;, function(err)&#123;//err是异常数据&#125;); 实例 1234567891011121314151617181920212223var vm = new Vue(&#123; el:'#app', data:&#123; myData:[], t1:'' &#125;, methods:&#123; jsonpData:function()&#123; this.$http.jsonp(\"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su\", //跨域请求接口 &#123; params: &#123; wd: this.t1, &#125;, jsonp: 'cb' &#125; ).then( function (res) &#123; this.myData = JSON.parse(res.bodyText).s &#125;) &#125; &#125; &#125;)","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://hudadahexiaolili.github.io/tags/Vue-js/"},{"name":"vue-rosource","slug":"vue-rosource","permalink":"https://hudadahexiaolili.github.io/tags/vue-rosource/"}]},{"title":"Vue中vetur插件提示 'v-for' directives require 'v-bind:key' directives.错误的解决办法","date":"2016-03-18T16:00:00.000Z","path":"2016/03/19/vue报错/","text":"在用vscode编写vue代码时，因为安装的有vetur插件，所以当代码中有v-for语法时，会提示 1[vue-language-server] 'v-for' directives require 'v-bind:key' directives. vue在升级到2.2后，当在组件中使用 v-for 时， key 现在是必须的。 下面是官方文档的说明: 回头看一下，我们写的代码 v-for中有key，但是为什么还报错呢？ 一脸蒙蔽~~ 去vetur插件的github上搜了一下，发现有人提这个报错问题，该插件的作者给出了解决办法： ``This is intended ESLint feature. You can turn off eslint check in future release. Setting vetur.validation.vue-html to false will disable it.`` 意思就是，这是ESLint的功能。对vue进行了eslint检查。 那么我们就把eslint对该插件的检查关闭， 在vscode中，打开 文件&gt;首选项&gt;设置 找到 vetur.configuration 把 “vetur.validation.template”: true 改成 “vetur.validation.template”: false 保存，我们再看一下vue文件，发现不报错了。","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://hudadahexiaolili.github.io/tags/Vue-js/"},{"name":"vue-for","slug":"vue-for","permalink":"https://hudadahexiaolili.github.io/tags/vue-for/"},{"name":"vetur","slug":"vetur","permalink":"https://hudadahexiaolili.github.io/tags/vetur/"}]},{"title":"构造 jQuery 对象","date":"2016-03-14T16:00:00.000Z","path":"2016/03/15/构造jQuery对象/","text":"jQuery 对象是一个 类数组对象,含有连续的整形属性、length 属性和大量的 jQuery 方法。jQuery 对象由构造函数 jQuery() 创建, $() 则是 jQuery() 的缩写。 构造函数 jQuery()如果调用构造函数jQuery()时传入的参数不同,创建jQuery对象的逻辑也会随机不同。构造函数 jQuery()有 7 种用法。如下图： jQuery( selector, [,context] )第一个参数 selector如果传入一个 **字符串参数** ,jQuery 会检查这个字符串是 选择器表达式 还是HTML代码。 如果是 选择器表达式,则会遍历文档,查找与之匹配的 DOM 元素,并创建一个包含了这些 DOM 元素引用的 jQuery 对象;如果没有元素与之匹配,则创建一个空的 jQuery 对象.当然,这个对象不包含任何元素,它的 length 属性为 0. 字符串参数是 HTML 代码的情况，在下面将会解释. 第二个参数 context默认情况下，对匹配元素的查找将从 根元素 document对象 开始，即查找范围是整个 文档树，不过也可以传入第二个参数 context 来限定查找范围( 我个人习惯把 context 当做” 上下文 “解读，类似于canvas绘图中的getContext ). 例如,在一个事件监听函数中，可以像下面这样限定查找范围: 1234$('div.foo').click(function() &#123; $('span',this).addClass('bar');//限定查找范围 // 选择器表达式 \"span\" 的查找被限定在 this 范围内，也就是只有被点击元素内的span元素才会被添加 类样式 \"bar\".&#125;) 如果 选择器表达式 selector 是简单的 “#id”,且没有指定 上下文 context，则调用浏览器的原生方法 document.getElementById() 查找属性 id 等于 指定值 的元素;如果是比 “#id” 复杂的选择器表达式或指定了上下文，则通过 jQuery 方法.find()查找，因此 $(&#39;span&#39;,this)等价于 $(this).find(&#39;span&#39;). jQuery(html,[,ownerDocument])、jQuery(html,props)第一个参数 HTML代码如果传入的 字符串参数 像 一段 HTML 代码，(例如，字符串中含有),jQuery会尝试用这段 HTML 代码 创建新的 DOM 元素，并创建一个包含了这些 DOM 元素 引用的 jQuery 对象. 例如,下面的代码将把 HTML 代码转换成 DOM 元素并插入 body 节点的末尾: 1$('&lt;p id=\"test\"&gt;My &lt;em&gt;new&lt;/em&gt; text &lt;/p&gt;').appendTo('body'); 如果 HTML 代码 是一个单独标签，例如，$(‘‘)或$(‘‘),jQuery 会使用浏览器原生方法 document.creatElement() 创建 DOM 元素。如果是比单独标签更复杂的 HTML 片段，例如上面例子的 $(‘My new text ‘).appendTo(‘body’);，则利用浏览器的 innerHTML 机制创建 DOM 元素，这个过程有方法 jQuery。buildFragment() 和 方法 jQuery.clean() 实现。 第二个参数 ownerDocument 和 props第二个参数 ownerDocument 用于指定创建新 DOM 元素的文档对象，如果不传入，则默认为 当前文档对象。 如果 HTML 代码是一个单独标签，那么第二个参数还可以是 props.props 是一个包含了属性、事件的 普通对象。在调用 document.creatElement()创建 DOM 元素后，参数 props 会被传给 jQuery 方法 .attr(),然后由 .attr() 负责把参数 props 中的属性、事件设置到新创建的 DOM 元素上。 参数 props 的属性可以是任意的 事件类型 (如: “click”),此时 属性值 应该是 事件监听函数，它将被绑定到新创建的 DOM 元素上; 参数 props 可以含有以下特殊属性: val、css、html、text、data、width、height、offset，相应的 jQuery 方法: .val() .css() .html() .text() .data() .text() .width() .height() .offset()将被执行，并且属性值会作为参数传入，其他类型的属性则会被设置到新创建的 DOM 元素上； 某些特殊属性还会做 跨浏览器兼容 (如 type、value、tabindex等)； 可以通过属性名 class 设置类样式，但要用 引号 把 class 包裹起来，因为class 是 JavaScript 保留字。例如： 12345678910//功能：创建一个 div 元素，并设置类样式 为\"test\"、设置文本内容为 \"Click me!\"、绑定一个click事件//然后插入到 body 节点的末尾，当点击该 div 元素时，还会切换类样式$(\"&lt;div/&gt;\", &#123; \"class\": \"test\", text: \"Click me!\", click: function () &#123; $(this).toggleClass(\"test\"); &#125;&#125;).appendTo(\"body\");","tags":[]},{"title":"自调用执行函数","date":"2016-03-13T16:00:00.000Z","path":"2016/03/14/自调用匿名函数/","text":"在前辈的基础上，添加了一些自己的理解，记录了自己不熟悉的知识点和盲点。 主要整理内容: 自调用执行函数 使用自调用函数的好处 自调用匿名函数的 三种 等价写法 自调用执行函数 jQuery的所有代码被包裹在一个立即执行的匿名函数表达式中，这种结构称为”自调用匿名函数”. 当浏览器加载完jQuery文件后，自调用匿名函数会立即开始执行，初始化jQuery的各个模块. 123456789//jQuery中的相关代码如下： (function (window, undefined) &#123; //构建 jQuery对象 var jQuery = ... // Expose jQuery to the global object window.jQuery = window.$ = jQuery; return jQuery;&#125;)(window); 为什么创建这样一个自调用匿名函数？通过创建一个自调用执行函数，创建了一个特殊的函数作用域(之前写过关于沙箱模式的一些理解，可以参考理解),该作用域中的代码不会和已有的同名函数、方法名和变量以及 第三方库冲突。 闭包可以确保jQuery的代码不受其他代码的干扰，并且jQuery也不会破坏或者最小程度的破坏和污染全局变量，降低对其他代码的影响。 在自调用匿名函数的最后，通过手动把变量jQuery添加到window对象上，明确地使变量jQuery成为公开的全局变量，而其他的部分将是私有的。 自调用匿名函数的 三种 等价写法123456789101112131415//写法1 (常用写法，jQuery采用这一种)(function () &#123; // ...&#125;)();//写法2(function () &#123; // ...&#125;());//写法3! function () &#123; //...&#125;();&lt;/script&gt; 为什么要为自调用匿名函数传入参数 window，并传入window对象？ 通过传入 window 对象，可以使 window 对象变为局部变量( 即把函数参数作为局部变量使用 )，这样当在jQuery中访问 window 对象时，不需要将作用域链回退到顶层作用域，从而更快的访问 window 对象. 将 window 对象作为参数传入，可以在压缩代码时进行优化。在压缩文件jQuery-1.7.1.min.js中被压缩为： 12(function(a,b)&#123;...&#125;)(window);//参数 window 被压缩为 a,参数 underfined 被压缩为 b 为什么要为自调用函数设置参数 undefined ?特殊值 undefined 是 window 对象的一个属性。通过下列代码可以验证：1alert('undefined' in window); //true 通过把参数undefined 作为局部变量使用，但是又不传入任何值，可以缩短查找 undefined 时的作用域链. 并且可以在压缩代码时进行优化，如前面所示，undefined 会被压缩为 b . 更重要的原因是，通过这种方式可以确保参数 undefined 的值是 undefined .因为 undefined 有可能被重写为新的值。 注意： 使用自调用匿名函数时，最好不要省略其之前和之后的 分号，否则可能抛出异常. 这个系列的学习都是基于高原著作的《jQuery技术内幕 深入解析jQuery架构设计与实现原理》的学习和理解. -感谢大神们的努力-","tags":[{"name":"自调用函数","slug":"自调用函数","permalink":"https://hudadahexiaolili.github.io/tags/自调用函数/"}]},{"title":"用 css 元素实现元素垂直居中","date":"2016-03-02T16:00:00.000Z","path":"2016/03/03/center/","text":"水平居中的方式 垂直居中的方式 水平居中 1.水平居中: 行内元素解决方案 只需要将行内元素包裹在一个属性为block的父级元素中，并把这个父级元素添加如下属性即可:1text-align:center; 试用元素: 文字、链接、其它inline或者inline-*类型的元素(如 inline-block,inline-table,inline-flex)实例:12345678910111213/*CSS代码片段*/nav, div&#123; text-align: center;&#125;/*Html代码片段*/&lt;div&gt;文字元素&lt;/div&gt;&lt;nav&gt; &lt;a href=\"\"&gt;链接元素01&lt;/a&gt; &lt;a href=\"\"&gt;链接元素02&lt;/a&gt; &lt;a href=\"\"&gt;链接元素03&lt;/a&gt;&lt;/nav&gt; 2.水平居中: 块级元素解决方案对于块级元素( display:block )来说，我们需要将它的外边距(即 margin-left和margin-right )设置为auto，即可实现块级元素的居中。 1234.center&#123; /* 这里可以设置顶端外边距 */ margin: 10px auto;&#125; 实例:1234567891011121314151617181920/*CSS 代码片段*//*解决方案：添加margin-left，margin-right属性值为auto即可，如下：margin: 0 auto;注意：需要居中的块元素需要有固定的宽度，否则无法实现居中，因为占据100%宽度*/div,p &#123; width: 200px; /* 这里需要设置元素宽度 */ height: 150px; background: #222; color: #FFF;&#125;/* 定义居中关键属性 */.center&#123; /* 这里可以设置顶端外边距 */ margin: 10px auto;&#125; 12345678910&lt;!--HTML 代码片段--&gt;&lt;!--居中元素：块状元素，如(div, p, section 等等元素），即display属性为block的元素--&gt;&lt;div class=\"center\"&gt; 水平居中的块级元素&lt;/div&gt;&lt;p class=\"center\"&gt; 水平居中的块级元素 &lt;/p&gt;&lt;!--现在可以看到居中效果的块状元素了 --&gt; 3.水平居中: 多个块状元素解决方案 如果页面里有多个块状元素需要水平排列居中，可以将元素的display属性设置为inline-block，并且把父元素的text-align属性设置为center即可实现。 实例: 123456789101112131415161718192021222324/*解决方案：设置这几个块状的元素display属性为inline-block，并且设置父元素text-align属性为center即可*/.center&#123; display:inline-block;&#125;body&#123; text-align:center;&#125;/* 元素美化 */div&#123; width: 100px; background: #222; height: 50px; color: #FFF; padding: 10px;&#125; 123456789101112131415161718&lt;!--HTMl 代码片段--&gt;&lt;!--居中类型：水平居中居中元素：“多个”块状元素水平横向排列居中--&gt;&lt;div class=\"center\"&gt;水平居中的块状元素&lt;/div&gt;&lt;div class=\"center\"&gt;水平居中的块状元素&lt;/div&gt;&lt;!--现在可以看到以上两个块状元素水平横向排列并且居中提示：如果需要将以上两个元素垂直排列居中的话，使用上一节的margin: 0 auto;即可实现--&gt; 4.水平居中:多个块级元素解决方案(使用flexbox布局实现) 使用flexbox布局，只需要把待处理的块状元素的父元素添加属性display:flex及justify-content:center即可 实例: 12345678910111213141516171819202122232425/*css代码片段*//*解决方案：设置需要水平居中的块状元素的父元素display为flex ，并且justify-content属性为center即可*/body&#123; display: flex; justify-content: center;&#125;/* 页面美化元素 */div&#123; width: 100px; background: #222; height: 50px; color: #FFF; padding: 10px; margin: 10px;&#125; 12345678910&lt;!--html 代码片段--&gt;&lt;!--居中类型：水平居中居中元素：“多个”块状元素水平横向排列居中 (使用flexbox布局实现)--&gt;&lt;div&gt;水平居中的块状元素&lt;/div&gt;&lt;div&gt;水平居中的块状元素&lt;/div&gt; 垂直居中 1.垂直居中:单行的行内元素解决方案 当一个行内元素，即inline,inline-*类型的元素需要居中的话，可以将它的line-height设置为父元素的高度，即可实现垂直居中的效果。 实例:123456789101112131415161718/*解决方案：将inline元素的line-height设为一致即可*/#container&#123; background: #222; height: 200px; text-align: center;&#125;/* 以下代码中，将a元素line-height设置的和父元素一样高度即可实现垂直居中 */a&#123; line-height:200px; color: #FFF;&#125; 12345678910&lt;!--居中类型：垂直居中居中元素：单行的inline类型元素，文字或者链接等--&gt;&lt;div id=\"container\"&gt; &lt;a href=\"#\"&gt;hello, xiaolili&lt;/a&gt;&lt;/div&gt; 2.垂直居中:多行的行内元素解决方案( Inline-Block ) 组合使用display:table-cell和vertical-align:middle属性和和一个伪元素让内容块处于容器中央来定义需要居中的元素的父容器元素生成效果.12345&lt;div class=\"Center-Container is-Inline\"&gt; &lt;div class=\"Center-Block\"&gt; &lt;!-- CONTENT --&gt; &lt;/div&gt; &lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334/*添加了一些小技巧:如果内容块宽度大于容器宽度，比如放了一个很长的文本，但内容块宽度设置最大不能超过容器的100%减去0.25em，否则使用伪元素:after内容块会被挤到容器顶部，使用:before内容块会向下偏移100%。如果你的内容块需要占据尽可能多的水平空间，可以使用max-width: 99%;（针对较大的容器）或max-width: calc(100% -0.25em)（取决于支持的浏览器和容器宽度）。*/.Center-Container.is-Inline &#123; text-align: center; overflow: auto; &#125; .Center-Container.is-Inline:after, .is-Inline .Center-Block &#123; display: inline-block; vertical-align: middle; &#125; .Center-Container.is-Inline:after &#123; content: ''; height: 100%; margin-left: -0.25em; /* To offset spacing. May vary by font */ &#125; .is-Inline .Center-Block &#123; max-width: 99%; /* Prevents issues with long content causes the content block to be pushed to the top */ /* max-width: calc(100% - 0.25em) /* Only for IE9+ */ &#125; 优点： 高度可变 内容溢出会将父元素撑开。 支持跨浏览器，也适应于IE7。 缺点： 需要一个容器 水平居中依赖于margin-left: -0.25em;该尺寸对于不同的字体/字号需要调整。 内容块宽度不能超过容器的100% - 0.25em。 3.垂直居中:负外边距(Negative Margins) 如果块元素尺寸已知，可以通过以下方式让内容块居中于容器显示：外边距margin取负数，大小为width/height（不使用box-sizing: border-box时包括padding，）的一半，再加上top: 50%; left: 50%;。即： 123456789.is-Negative &#123; width: 300px; height: 200px; padding: 20px; position: absolute; top: 50%; left: 50%; margin-left: -170px; /* (width + padding)/2 */ margin-top: -120px; /* (height + padding)/2 */ &#125; 测试表明，这是唯一在IE6-IE7上也表现良好的方法。 优点： 良好的跨浏览器特性，兼容IE6-IE7。 代码量少。 缺点： 不能自适应。不支持百分比尺寸和min-/max-属性设置。 内容可能溢出容器。 边距大小与padding,和是否定义box-sizing: border-box有关，计算需要根据不同情况。 4.垂直居中: 变形(Transforms) 内容块定义transform: translate(-50%,-50%)必须带上浏览器厂商的前缀，还要加上 top: 50%; left: 50%; 123456789.is-Transformed &#123; width: 50%; margin: auto; position: absolute; top: 50%; left: 50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%); &#125; 优点： 内容可变高度 代码量少 缺点： IE8不支持 属性需要写浏览器厂商前缀 可能干扰其他transform效果 某些情形下会出现文本或元素边界渲染模糊的现象 5.垂直居中:表格单元格( Table-Cell ) 总的说来这可能是最好的居中实现方法，因为内容块高度会随着实际内容的高度变化，浏览器对此的兼容性也好。最大的缺点是需要大量额外的标记，需要三层元素让最内层的元素居中。 12345678910111213/*内层元素使用 display:table-cell外层元素使用 display:table*/.Center-Container.is-Table &#123; display: table; &#125; .is-Table .Table-Cell &#123; display: table-cell; vertical-align: middle; &#125; .is-Table .Center-Block &#123; width: 50%; margin: 0 auto; &#125; 1234567&lt;div class=\"Center-Container is-Table\"&gt; &lt;div class=\"Table-Cell\"&gt; &lt;div class=\"Center-Block\"&gt; &lt;!-- CONTENT --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 优点： 高度可变 内容溢出会将父元素撑开。 跨浏览器兼容性好。 缺点： 需要额外html标记 6.垂直居中: 利用Flexbox实现垂直居中 这是CSS布局未来的趋势。Flexbox是css3新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题.记住Flexbox不只是用于居中，也可以分栏或者解决一些令人抓狂的布局问题。 1234567891011121314151617/*父元素*/.container&#123; width: 300px; height: 200px; border: 3px solid #546461; display: flex;/*1*/ display: -webkit-flex; align-items: center;/*2*/ -webkit-align-items: center; justify-content: center;/*3*/ -webkit-justify-content: center; &#125; /*子元素*/ .inner&#123; border: 3px solid #458761; padding: 20px; &#125; 优点： 内容块的宽高任意，优雅的溢出。 可用于更复杂高级的布局技术中。 缺点： IE8/IE9不支持。 Body需要特定的容器和CSS样式。 运行于现代浏览器上的代码需要浏览器厂商前缀。 表现上可能会有一些问题。 7.绝对居中( Absolute Centering ) 强烈推荐 我们经常用margin:0 auto来实现水平居中，而一直认为margin:auto不能实现垂直居中……实际上，实现垂直居中仅需要声明元素高度和下面的CSS:12345.Absolute-Center &#123; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; &#125; 居中方式: 内容块的父容器设置为position:relative，使用上述绝对居中方式，可以使内容居中显示于父容器。123456789101112.Center-Container &#123; position: relative; &#125; .Absolute-Center &#123; width: 50%; height: 50%; overflow: auto; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; &#125;","tags":[{"name":"css","slug":"css","permalink":"https://hudadahexiaolili.github.io/tags/css/"},{"name":"垂直居中","slug":"垂直居中","permalink":"https://hudadahexiaolili.github.io/tags/垂直居中/"}]},{"title":"js some,foreach,map,filter,every对比","date":"2016-02-11T16:00:00.000Z","path":"2016/02/12/some-every/","text":"希望通过这篇笔记,加深自己对 ES5 新增的数组方法的理解,可以帮我们少一些 for 循环. […].some(ck)函数 —- 某个一个为true,则为true some意指”某些”,指是否”某些项”合乎条件。 皇上:有一个满意的，就来侍寝就可以了。 (对数组中每个元素执行一次ck函数,直到某个元素返回true,则直接返回true。如果都返回false,则返回false。) 返回值为 Boolean 值。 检查整个数组中是否有满足ck函数的元素。1234var result = [1,5,3,6].some( (v,i) =&gt; (v&gt;10) ) //所有元素都不满足，返回result = falsevar result = [10,5,30,60].some( (v,i) =&gt; (v&lt;10) ) //有一个(多个)满足，返回result = true […].every(ck)函数 —- 某一个为false，则返回false 跟some为基友关系，同样是返回Boolean值。 与some相比就是true和false调换一下。 (每个数组元素都执行一次ck函数，直到某个元素执行函数ck返回false,则直接返回false,如果全部返回true，则返回true) 不过，every需要每一个妃子都要让朕满意，否则——“来人，给我拖出去砍了！”1234var result = [5,50,35,12,85].every( (v,i) =&gt; v&lt;51 ) //返回有一个(多个)大于等于51,则返回 result = falsevar result = [5,50,35,12,85].every( (v,i) =&gt; v&lt;100 ) //全部小于100,则返回 result = true […].foreach(ck)函数 —- 循环而已 每个数组元素都执行一次ck函数，foreach函数无法用break跳出 12[50, 25, 49].forEach( (v,i) =&gt; console.log(v) );//50 25 49 […].filter(ck)函数 —- 得到返回值为true的元素的集合 每个数组元素都执行一次ck函数，最后返回每次元素执行ck函数后返回值的为true的元素集合(数组)12var newArray = [50,2,60,4,53,15].filter( (v,i) =&gt; (v&gt;10) ) //返回数组中大于10的元素新数组 newArray = [50,60,53,15] […].reduce(ck,init) —- 依次执行ck(prv,next) 数组依次执行ck函数。 12var result = [0,1,2,3]restult.reduce((a,b)=&gt; a+b,0) // 返回 6 […].map(ck)函数 —- 返回每个元素返回值的集合 每个数组元素都执行一次ck函数，最后返回每次元素执行ck函数后返回值的集合(数组) 12var newArray = [50,30,40].map( (v,i) =&gt; v/10 ) //每个元素除以10，最后返回一个新数组 newArray = [5,3,4]","tags":[{"name":"some","slug":"some","permalink":"https://hudadahexiaolili.github.io/tags/some/"},{"name":"foreach","slug":"foreach","permalink":"https://hudadahexiaolili.github.io/tags/foreach/"},{"name":"map","slug":"map","permalink":"https://hudadahexiaolili.github.io/tags/map/"},{"name":"filter","slug":"filter","permalink":"https://hudadahexiaolili.github.io/tags/filter/"},{"name":"every","slug":"every","permalink":"https://hudadahexiaolili.github.io/tags/every/"},{"name":"JS数组","slug":"JS数组","permalink":"https://hudadahexiaolili.github.io/tags/JS数组/"}]},{"title":"js 静态方法和实例方法的区别","date":"2016-01-11T16:00:00.000Z","path":"2016/01/12/staticMethod/","text":"希望通过这篇笔记，加深自己对 JavaScript 对象里面的静态方法、实例方法的理解。把自己理解整理如下结构: 静态方法和实例方法的声明方式 静态方法和实例方法的调用方式 静态方法和实例方法的声明方式 123456789101112function user(a, n)&#123; this.a = a||'年龄'; this.n = n||'名字'; &#125; //声明静态变量 user.sayname = function()&#123; alert(this.name); &#125; //声明动态变量 user.prototype.sayname2 = function()&#123; alert(this.name); &#125; 静态方法和实例方法的调用方式 123456789101112function A()&#123; &#125;A.staticMethod = function()&#123; alert('静态方法');&#125;A.prototype.instaceMethod = function()&#123; alert('实例方法');&#125;A.staticMethod();var instace = new A();instace.instaceMethod(); 可以这么理解，静态方法是类直接调用，实例方法要new 出来的对象才能调用。 小结 从定义上，实例方法要用到function这个对象中的prototype属性来定义，静态方法通过A.直接定义；从方法调用上，静态方法可以直接通过A.来调用，实例方法要通过先定义一个引用变量，指向构造函数定义的新对象。","tags":[{"name":"静态方法","slug":"静态方法","permalink":"https://hudadahexiaolili.github.io/tags/静态方法/"},{"name":"动态实例方法","slug":"动态实例方法","permalink":"https://hudadahexiaolili.github.io/tags/动态实例方法/"}]},{"title":"闭包的学习","date":"2015-09-11T16:00:00.000Z","path":"2015/09/12/闭包/","text":"本文主要记录了自己关于闭包的理解，和闭包的应用闭包的概念闭包，就是函数在调用的时候，产生的那个内存结构，外界不能访问里面，它就是一个封闭的包裹结构，即闭包。 注意 函数定义后，放置在那里,只是一个普通的对象，不会创建任何内存，也不会影响到其他任何东西; 只有函数运行起来，在函数执行过程中，在 结束之前，函数会构成一个封闭的空间； 根据词法作用域，函数内在访问变量的时候，如果函数内没有可以到函数外面查找，反之不行； 同时函数也包含了一定的范围； 结合一下， 此时在函数结束之前，函数构成了一个封闭的包裹的结构，此为闭包。 如何保留函数内存的访问能力 函数在执行完之后，会释放其占用的内存。 如果可以让函数调用之后，不释放其内存，这个闭包才会有作用。 函数执行结束之后，如果保存其内存的访问能力，该内存就不会被释放。 闭包要使用，有一个经典的代码，一定要有： 12345678function foo()&#123; var num = 123; function func()&#123; return num; &#125; return func;&#125;var f = foo(); 思考：闭包到底构成了什么东西(有闭包和没有闭包有什么不同，闭包给我们提供了一个什么样的功能)？ 123发现，闭包改变了变量的访问规则( 改变了作用域 ).闭包 给我们提供了一个 私有作用域.凡是需要 保护 使用 的数据都可以放到私有作用域中. 思考：函数就是闭包？ 这种理解并不准确。当函数 **被调用** 的时候，才会产生闭包。 举个例子，有一个铅笔，把它放在头发上来回摩擦，摩擦这个动作会产生静电。 但如果把铅笔放在桌子上，啥也不做，就不会产生静电。 而且摩擦产生静电之后，如果不继续保持摩擦，静电就会消失。因此我们需要保持持续的摩擦。 闭包的几种应用 1.沙箱模式那么什么是沙箱呢？ 1234567沙箱 可以用一个我们生活中的例子来描述： 网上下载的软件，但是我们并不知道下载的软件有没有病毒，一般的杀毒软件都会提供一个沙箱运行模式。其特点是在里面运行的任何程序，在沙箱重启后其影响会全部消失。但是沙箱会模拟当前操作系统的所有访问资源。在很多手机 app 中也有相应的沙箱模型。例如一个软件是病毒，安装之后，理论只允许其在自己所在的沙箱里面运行，不允许访问其他 app 所在的文件。 因此沙箱的特点就是：既可以运行，又可以脱离。 我们知道，自己在封装一些东西的时候，容易出现 全局污染.我们可以把其放到一个沙箱中，留出一个允许别人使用的 接口( 函数， 对象 ) . 我们的代码不会或者最小程度的影响到外界代码。 如何构成沙箱呢，我们可以使用下面的代码构成沙箱 12345678(function ()&#123; // 代码 // 1,... // 2,... // 3,...&#125;)(); 沙箱模式 可以保证数据内外隔离，但在实际开发中，我们需要预留一些 api 以供外界调用，有几个常见的返回模型。 1.利用 返回值，返回一个 接口 1234var func= (function () &#123; // ... return func;&#125;)(); 2.利用 window 的属性返回多个数据 1234(function () &#123; // ... window.jQuery = window.$ =jQuery;&#125;)(); 3.利用 函数的调用中的函数调用模式 函数在调用的时候，默认 函数中的 this 就是 window. 因此第二种写法有一个变体： 1234( function () &#123; // ... this.jQuery = this.$ = jQuery;&#125;) 2. 利用闭包实现私有作用域(带私有作用域的函数)代码模型： 123456789101112//一般写函数：var foo =function () &#123; //函数体&#125;；//可以使得函数具有私有内存var foo = (function () &#123; //私有内存空间 return function () &#123; // 函数体 &#125;；&#125;)();//这个带有私有内存的函数，在实际开发中可以不使用，但是如果使用会比较方便 让我们来看一个例子： 需求： 1&gt; 将骆驼命名规则的字符串转换成使用 连字符连接的 字符串, 并且全小写 例如: &apos;getElementById&apos; =&gt; &apos;get-element-by-id&apos; 2&gt; 将用连字符连接的字符串, 转成骆驼命名规则的字符串, 例如: &apos;get-element-by-id&apos; =&gt; &apos;getElementById&apos; 12345678910111213141516171819202122232425262728293031323334353637//将骆驼命名规则的字符串转换成使用 连字符连接的 字符串, 并且全小写var toCamlize = ( function () &#123; var cache = &#123;&#125;;//将缓存包裹到函数中 return function toCamlize( str ) &#123; var ret = cache[ str ]; if ( ret ) &#123; //判断内存中是否存在这个参数，如果存在，返回这个数的值 return ret; &#125; else &#123;//如果缓存中不存在这个数 ret = str.replace( /-(.)/g, function (_,g) &#123; return g.toUpperCase(); &#125;); //replace 的第二个参数可以是一个函数, 利用正则匹配字符, //每一个匹配会调用一次函数, 并且用函数的返回值来替换匹配到的结果. //重点是函数的参数, 回调函数的参数是如下方式分配的 //function ( 匹配到的项, 第1组, 第2组, 第3组, ... ) &#123; ... &#125; cache [ str ] = ret;//将这个数添加到内存 return ret; &#125; &#125;;&#125;)();//2&gt; 将用连字符连接的字符串, 转成骆驼命名规则的字符串var toBarCase = (function () &#123; var cache = &#123;&#125;; return function toBarCase( str ) &#123; var ret = cache[ str ]; return ret || cache[ str ] = str.replace( /[A-Z]/g, function ( s ) &#123; return '-' + s.toLowerCase(); &#125; ); &#125;; &#125;)(); 3.保留运行时的数据–&gt; 闭包 是函数在执行过程中产生的一个私有的内存空间 这个内存空间如果在函数执行结束后不释放，也可以保留数据 12345678910111213141516// 例如：var func = (function (num) &#123; // 私有的内存空间 return function （） &#123; // ... &#125;&#125;)(2);//抽象一下function createFuncWidthSavable( value ) &#123; return function () &#123; &#125;;&#125;var fn = createFuncWidthSavable( 123 ); 利用这点，我们可以使用闭包实现0-9的打印 1234567891011121314for ( var i = 0; i &lt; 10; i++ ) &#123; setTimeout((function ( value ) &#123; return function () &#123; console.log( value ); &#125; &#125;)( i ), 200);&#125;// for ( let i = 0; i &lt; 10; i++ ) &#123;// setTimeout(function () &#123;// console.log( i );// &#125;, 200);// &#125;","tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://hudadahexiaolili.github.io/tags/面向对象/"},{"name":"闭包","slug":"闭包","permalink":"https://hudadahexiaolili.github.io/tags/闭包/"},{"name":"沙箱模式","slug":"沙箱模式","permalink":"https://hudadahexiaolili.github.io/tags/沙箱模式/"}]},{"title":"Hexo部署博客的err","date":"2015-09-11T16:00:00.000Z","path":"2015/09/12/hexo 报错/","text":"错误1 在使用hexo部署博客到gitcafe的时候，出现了如下错误: 12345678910INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...fatal: Not a git repository (or any of the parent directories): .gitFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: Not a git repository (or any of the parent directories): .git at ChildProcess.&lt;anonymous&gt; (E:\\blog\\HexoBlog\\node_modules\\hexo-util\\lib\\spawn.js:37:17) at emitTwo (events.js:87:13) …… 解决方法 12删除.deploy文件夹，重新生成即可解决该问题哈哈哈，抖机灵。成功。 权限错误 1234567891011Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Warning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rights 有网友们有建议将deploy处设置不要使用https，而是改为SSH，如下： 1repository: https://github.com/username/username.github.io.git 修改为: 1repo：git@github.com:username/username.github.io.git 各种姿势修改都不对，究竟怎样使我们的博客可以重新部署到github上 当部署失败的时候，请按照以下步骤进行：1.检查是否有SSH key 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ，查看是否有SSH keys。如果有，直接跳到第（3）步；如果没有，则继续。 2.新建 SSH key，在git shell(或者git bash等命令窗口)，注意大小写： 1$ ssh-keygen -t rsa -C \"邮箱名\" 然后出现: 12Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/dell/.ssh/id_rsa): 直接回车就可以。然后会出现： 12Enter passphrase (empty for no passphrase):Enter same passphrase again: 要求你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 注意：输入密码的时候没有*字样的，直接输入就好。然后会出现： 123456789101112131415Your identification has been saved in /c/Users/dell/.ssh/id_rsa.Your public key has been saved in /c/Users/dell/.ssh/id_rsa.pub.The key fingerprint is:65:69:······02:4b emailname@email.comThe key's randomart image is:+--[ RSA 2048]----+| || . o . || . o o = o || . o * = o || E o + o . || . o. . . || .. |+-----------------+ 至此，密钥已经成功生成 接下来在github上添加SSH key： ① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/dell/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。 ② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。 ③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）。 4.测试设置是否成功： 1$ ssh -T git@github.com 出现： 12Hi username! You've successfully authenticated, but GitHub does not provide shell access. 5.设置用户信息： 12$ git config --global user.name \"用户名\"$ git config --global user.email \"你希望的邮箱名\" 6.然后就可以部署你的博客到github了 12$ hexo g$ hexo d 结束...","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hudadahexiaolili.github.io/tags/Hexo/"}]},{"title":"函数的四种调用模式","date":"2015-09-11T16:00:00.000Z","path":"2015/09/12/函数的四种调用模式/","text":"参数this在面向对象编程中非常重要，它的值取决于 调用的模式。前言： 函数一般分为四种调用模式： 1.函数调用模式： 一般独立函数调用 2.方法调用模式： 作为方法调用，一定要有一个引导对象(宿主对象) 3.构造器调用模式： 一定用来初始化对象，有 new 引导，return 可以重定向 4.上下文调用模式： apple 或 call 函数调用模式 函数的定义方式 声明式 表达式式 Function 单独独立调用的就是函数 函数名(参数); 函数调用模式中，this 表示 全局对象 window 方法调用模式 方法本身就是函数，但是方法不是单独独立的使用，而是通过对象引导调用 对象.方法( 参数 ); 方法调用模式中， this 指向引导方法的对象 方法调用一定要有宿主对象 方法一定是 某个对象 的 方法。对象可以是任何对象 1234567891011121314function foo() &#123; console.log( this );&#125;var o = &#123; name : \"Tom\" &#125;;o.foo = foo;foo(); //函数调用o.foo();//方法调用--------------------------function func () &#123; console.log(' 函数也是是对象 ');&#125;func.foo = foo;foo();//函数调用func.foo();//方法调用 构造器调用模式(构造函数模式 或 构造方法模式) constructor 特征: 在函数前面用 new 来引导 this 的含义: 刚刚被创建出来的实例对象 注意返回值 调用构造函数时，无参可省略括号 执行步骤 123456789101112var p = new Person();// new 是运算符，用来申请创建对象，创建出来的对象传递给构造函数的 this//利用构造函数对其初始化function Person () &#123; this.name = \"Tom\"; this.age = \"19\"; this.gender = \"男\";&#125;// 返回值// 如果不写return，那么构造函数 默认返回 this// 若在构造函数中写return ,并紧跟基本类型(如 return num,ruturn 123).则忽略返回类型// 若在构造函数中写return,并紧跟 引用类型 ，那么构造函数返回 该引用类型数据，忽略 this 构造函数小结 (1) 构造函数无参数，可以省略括号 1var p = new Person; (2) 创建对象并直接调用 其方法 12345( new Person () ).sayHello();//可以省略调整结合性的括号new Person ().sayHello();//若省略构造函数的括号，就必须加结合性的括号( new Person ).sayHello (); 上下文调用模式 特征: 一定是由一个对象引导调用 this 的含义: 引导调用的这个对象 -&gt; 上下文调用模式 -&gt; 术语 上下文: 就是 this. -&gt; 上下文调用模式有标准的调用语法: 函数名.call( ... ) 函数名.apply( ... ) -&gt; 上下文调用模式这两个形式功能一模一样. 只是参数的形式不同. -&gt; 上下文调用之所以称为上下文调用, 是因为我们允许利用参数来改变 this 的含义. 1234567891011例如: var o1 = &#123; name: 'jim' &#125;; var o2 = &#123; name: 'tom' &#125;; function func() &#123; console.log( this ); &#125; func() // 函数模式 =&gt; window o1.func = func; o1.func(); // 方法模式 =&gt; o1 func.call( o1 ); // this 就是 o1 func.call( o2 ); // this 就是 o2 func.call( null ); // this 就是 window 说明: 在利用上下文调用的时候, call 或 apply 的第 0 个参数表示就是 函数中 this 的指向 如果传入 null 或 undefined 或不传, this 就是 window 如果传入的是 对象, this 就是传入对象 如果传入的是 基本类型( 数字, 字符串, boolean )就会将基本类型转换成对应包装类型, 赋值给 this -&gt; 关于参数 call 在调用的时候, 函数的参数散列的在 call 中提供. apply 在调用的时候, 函数的参数以数组的形式提供. 12345678910111213141516171819202122232425例如: ( 填空题 ) function func( num1,num2 ) &#123; console.log( num1 + num2 ); &#125; 如果用 call 来调用, 下面的代码 与 func( 1, 2 ) 调用等价 func.call( null, 1, 2 ) 如果用 apply 来调用, 下面的代码与 func( 3, 4 ) 调用等价 func.apply( null, [ 3, 4 ] )验证: 看下面这个代码: function func( arr, callback ) &#123; for ( var i = 0; i &lt; arr.length; i++ ) &#123; callback( arr[ i ], i ); &#125; &#125; 这个 func 用 call 和 apply 分别怎么调用 如果以函数的形式调用 func( 'a,b,c'.split( ',' ), function ( v, i ) &#123; console.log( i + ', ' + v ); &#125; )注意: 有了这个写法, 表示以前凡是使用 函数 与 方法的地方都可以修改成 上下文调用模式例如: var html = template( 'tpl', &#123;&#125; ); =&gt; var html = template.call( null, 'tpl', &#123;&#125; ); var html = template.apply( null, [ 'tpl', &#123;&#125; ] );","tags":[{"name":"apply","slug":"apply","permalink":"https://hudadahexiaolili.github.io/tags/apply/"},{"name":"call","slug":"call","permalink":"https://hudadahexiaolili.github.io/tags/call/"},{"name":"函数调用模式","slug":"函数调用模式","permalink":"https://hudadahexiaolili.github.io/tags/函数调用模式/"}]},{"title":"AJAX和模板引擎","date":"2015-08-19T16:00:00.000Z","path":"2015/08/20/AJAX和模板引擎/","text":"理解同步、异步，掌握ajax概念以及如何发起ajax请求，了解模板引擎及其简单实现原理AJAX定义 AJAX 不是 JavaScript 的规范，它是”Asynchronous JavaScript and XML”的缩写,意思是用JavaScript执行 异步 网络请求. AJAX 不是一门新的语言，而是对现有技术的综合利。 简单说, AJAX 就是 浏览器 和 服务器 之间进行 异步交互 无需刷新页面 的技术。 说到这，让我们来了解一下 异步 的相关知识： 异步和同步异步 的定义异步 指的是某段程序执行时不会阻塞其他程序的执行，其表现形式为程序的执行顺序，不依赖程序本身的 书写顺序，相反为同步。 独立是异步的区别 ，省时是异步的理由。 生活中的例子打电话是同步，发消息是异步。 异步的优势异步 的优势在于不阻塞程序的执行，从而提升整体执行效率。 那么如何在 浏览器 上使用 AJAX 呢首先了解 AJAX 的原理: 在现代浏览器上书写AJAX主要依靠XMLHttpRequest对象。 认识 XMLHttpRequest 对象1234567891011121. 什么是XMLHttpRequest对象？ XMLHttpRequest是浏览器的内置对象，用于在后台和服务器通信（交换数据），XMLHttpRequest 对象提供了在网页加载后与服务器进行通信的方法。由此我们可以实现对网页的部分更新，而不是刷新整个页面。XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。2.XMLHttpRequest的主要作用：- 在不重新加载页面的情况下更新网页- 在页面已加载后从服务器请求数据- 在页面已加载后从服务器接收数据- 在后台向服务器发送数据3.注意：尽管名为 XMLHttpRequest，它并不限于和 XML 文档一起使用：它可以接收任何形式的文本文档。 让我们通过一个具体案例更清晰的了解它点击按钮，获取后台数据，显示到浏览器上。(不刷新页面) HTML代码 12345678910111213&lt;body&gt; &lt;input type=\"button\" value=\"获取数据\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;头像&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;&lt;th&gt;爱好&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; //接收数据，在这里输出 &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt; 后台 php 代码 123456789&lt;?php// 服务器告诉浏览器用什么样的方式解析读取到的内容header(\"Content-Type:application/json;charset=UTF-8\");$content = file_get_contents('./jsoncase.json');echo $content;?&gt; JSON 数据 12345678910111213141516[&#123;\"name\":\"悠悠\",\"photo\":\"./images/gg.jpg\",\"sex\":\"男\",\"age\":18,\"hobby\":\"两只老虎\"&#125;,&#123;\"name\":\"小杨\",\"photo\":\"./images/ss.jpg\",\"sex\":\"男\",\"age\":43,\"hobby\":\"污妖王\"&#125;...] 创建XMLHttpRequest对象 通过一行简单的JavaScript代码，我们就可以创建XMLHttpRequest对象。 在所有的现在浏览器（包括IE7）: 在IE5和IE6中：1234567//如果你想把标准写法和IE写法兼容在一起，可以这么写：var request;if (window.XMLHttpRequest) &#123; request = new XMLHttpRequest();&#125; else &#123; request = new ActiveXObject('Microsoft.XMLHTTP');&#125; 具体代码实现123456789101112131415161718192021222324252627282930313233343536373839404142// 1.获取按钮var oBtn = document.querySelector(\"input\");//2.添加事件oBtn.onclick = function () &#123; // 3.实例化对象 //var xhr= new XMLHttpRequest();（一般这样写就OK） //兼容 var xhr; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; // 4.设置请求行 xhr.open('post','./jsonCase.php');//xhr.open(请求方式，请求地址，是否异步);默认为asny:true;即异步 // 5.设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); // 6.设置请求正文（有格式key=value&amp;key=value,如果是get请求，那么请求正文在url后面，请求正文的send方法为null） xhr.send(null); // 7.监听并处理响应 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; // console.log(xhr.responseText); // 如何获取json中的数据 var result =JSON.parse(xhr.responseText); // console.log(result); var html= \"\"; for(var i =0;i&lt;result.length;i++)&#123; html+= \"&lt;tr&gt;\"+ \"&lt;td&gt;\"+result[i].name+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+\"&lt;img src=\"+result[i].photo+\"&gt;\"+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+result[i].age+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+result[i].height+\"&lt;/td&gt;\"+ \"&lt;td&gt;\"+result[i].hobby+\"&lt;/td&gt;\"+ \"&lt;/tr&gt;\";//如果字符串负责，拼接字符串会很繁琐 &#125; // console.log(html); document.querySelector('table').innerHTML= html; &#125; &#125;&#125; 注意事项 发送GET请求时 12345678910oBtn.onclick = function () &#123; //发送GET请求 //1.调用xhrt对象的open()方法建立一个连接 //①method参数：请求方式 //②url参数：请求的目标地址 //发送请求参数：附着在URL地址后面 xhr.open(\"get\", \"?userName=Tom2015\"); //2.调用xhrt对象的send()方法发送请求数据 xhr.send();&#125;; 发送POST请求 123456789oBtn.onclick = function () &#123; //发送POST请求//发送请求参数：将请求参数键值对以参数形式传递给send()方法xhr.open(\"post\", \"./jsonCase.php\");//设置请求消息头为如下的值：//Content-Type:application/x-www-form-urlencodedxhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");xhr.send(\"userName=Jerry2015&amp;userPwd=123456\");&#125;; 这一点详情见我以前总结的相关于请求报文和响应报文的文章 如何更简单的发起 ajax 请求：12345678910111213141516171819202122232425jQuery Ajax操作函数&gt; $.ajax()配置项type 默认值: \"GET\")。请求方式 (\"POST\" 或 \"GET\")， 默认为 \"GET\"。url 默认值: 当前页地址。发送请求的地址。data 发送到服务器的数据。将自动转换为请求字符串格式。processData 默认情况下，通过data选项传递进来的数据，如果是一个对象都会处理转化成一个查询字符串dataType 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断如果为json:它首先尝试使用 JSON.parse()。如果浏览器不支持，则使用一个函数来构建。如果为jsonp 类型，那么当从服务器接收到数据时，实际上是用了 &lt;script&gt; 标签而不是 XMLHttpRequest 对象。如果为text 和 xml 类型返回的数据不会经过处理。数据仅仅简单的将 XMLHttpRequest 的 responseText 或 responseHTML 属性传递给 success 回调函数。timeout设置请求超时时间（毫秒）。&gt; $.get(url,data,success(data, textStatus),dataType);&gt; $.post(url,data,success(data, textStatus),dataType); 上面我们发现，拼接字符串会很繁琐，那么如何让拼接字符串变得更简单 使用模板引擎1.模板引擎介绍1234JavaScript 模板引擎是将 HTML 结构从包含它们的内容中分离的方法。使用模板引擎的原因是当页面比较复杂的时候。拼接字符串麻烦且容易出错。JavaScript模板引擎可以帮我们解决这个问题。拼接字符串是麻烦但是如果对于简单的布局 就别用模板引擎如果页面比较复杂 或者需要的数据的页面比较麻烦 那么才用模板引擎 2.常见的模板引擎1.art-template(腾讯) 2.BaiduTemplate(百度) 3.Velocity(阿里) 4.Handlebars 每个模板都有自己的语法，详情见各自的readme.md,下面只阐述一下art-template的原生语法，方便初学者入门 3.art-template 语法12345678910&lt;1&gt;.引入模板引擎的包&lt;2&gt;.创建模板 模板中的变量就是对象的属性 &lt;%title%&gt; 不输出 &lt;%=title%&gt; 输出到html上&lt;3&gt;.获取数据&lt;4&gt;.把数据和模板绑定起来template(id,对象) 返回绑定好的html字符串 4.深入探究模板的原理123456789101112131415161718192021222324252627282930313233343536373839404142==&gt;1 //利用正则表达式的方法，找到字符串中特定自负，替换为数据对应的值 &lt;script&gt; // 有一个字符串 var html = '我叫&lt;% name %&gt;，我今年&lt;% age %&gt;岁了，我在&lt;% school %&gt;学习'; // 数据 var data = &#123; name: '小明', age: 18, school: '某大' &#125; var reg = /&lt;%\\s*([^%&gt;]\\S+)\\s*%&gt;/; // /&lt;%\\s*([^%&gt;]\\S+)\\s*%&gt;/这是整个表达式 &lt;% name %&gt; &lt;% age %&gt; &lt;% school %&gt; // ([^%&gt;]\\S+) 这是一个子表达式 name age school // exec() match() test() 方法属于正则表达式的三个方法 // exec()匹配一个正则表达式 如果该表达式还有子表达式 那么会把整个表达式的匹配的结果和子表达式匹配的结果 当作数组返回 var match = reg.exec(html); // console.log(match); html = html.replace(match[0], data[match[1]]); console.log(html); match = reg.exec(html); // console.log(match); html = html.replace(match[0], data[match[1]]); console.log(html); match = reg.exec(html); // console.log(match); html = html.replace(match[0], data[match[1]]); console.log(html); match = reg.exec(html); console.log(match); //如果没有匹配的结果之后返回null &lt;/script&gt; 12345678910111213141516171819202122==&gt;2 //简化代码 &lt;script&gt; // 有一个字符串 var html = '我叫&lt;% name %&gt;，我今年&lt;% age %&gt;岁了，性别&lt;%sex%&gt;，我在&lt;% school %&gt;学习'; // 数据 var data = &#123; name: '小明', age: 18, school: '某大', sex: '男' &#125; var reg = /&lt;%\\s*([^%&gt;]\\S+)\\s*%&gt;/; var match = null; while (match = reg.exec(html)) &#123; html = html.replace(match[0], data[match[1]]); &#125; console.log(html); &lt;/script&gt; 12345678910111213141516171819202122232425262728==&gt;3 //封装函数 &lt;p&gt;&lt;/p&gt; &lt;script type=\"text/template\" id=\"tmpl\"&gt; 我叫&lt;span&gt;&lt;% name %&gt;&lt;/span&gt;，我今年&lt;span&gt;&lt;% age %&gt;&lt;/span&gt;岁了，我在 &lt;% school %&gt;学习; &lt;/script&gt; &lt;script&gt; // 数据 var cc = &#123; name: '小明', age: 18, school: '某大' &#125; // 封装template函数 function template(id, data) &#123; var html = document.getElementById(id).innerHTML; var reg = /&lt;%\\s*([^%&gt;]\\S+)\\s*%&gt;/; var match = null; while (match = reg.exec(html)) &#123; html = html.replace(match[0], data[match[1]]); &#125; return html; &#125; var html = template('tmpl', cc); // console.log(html); document.querySelector(\"p\").innerHTML = html; &lt;/script&gt;","tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://hudadahexiaolili.github.io/tags/AJAX/"},{"name":"同步","slug":"同步","permalink":"https://hudadahexiaolili.github.io/tags/同步/"},{"name":"异步","slug":"异步","permalink":"https://hudadahexiaolili.github.io/tags/异步/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://hudadahexiaolili.github.io/tags/模板引擎/"}]},{"title":"如何将本地仓库和github仓库关联起来","date":"2015-04-03T16:00:00.000Z","path":"2015/04/04/如何将本地仓库和github仓库关联起来/","text":"当你在 GitHub 创建一个代码仓库后，需要將其与你的本地仓库关联起来。 123456789101112131415//把本地项目变成版本仓库git init //把目录当前目录下所有的文件信息添加到索引库的暂存区里面去git add -A //通过命令git commit 把刚刚提交到暂存区里的文件提交到仓库。//git commit -m \"提交所有文件\"，-m 后面的文字是注释，方便查看历史记录时知道每一次提交提交的是什么git commit -m \"First commit\" //开始把本地仓库的内容推送到GitHub仓库。git remote add origin https://github.com/.../.git(自己的仓库地址)//然后通过命令git push把本地仓库的内容推送到github仓库去。//第一次推送在git push后面加上参数-u，使用-u选项指定一个默认主机。git push -u origin master 以上操作基本上就是最简单的从把本地项目目录变成Git仓库，然后在把内容推送到自己的github上面","tags":[{"name":"github","slug":"github","permalink":"https://hudadahexiaolili.github.io/tags/github/"},{"name":"github仓库","slug":"github仓库","permalink":"https://hudadahexiaolili.github.io/tags/github仓库/"},{"name":"本地仓库","slug":"本地仓库","permalink":"https://hudadahexiaolili.github.io/tags/本地仓库/"}]},{"title":"快速理解原型链","date":"2015-03-13T16:00:00.000Z","path":"2015/03/14/快速理解JS中的原型链/","text":"JS中原型链的理解一、了解构造函数、原型和实例之间的关系( 实例原型三角形 )123在 js 中凡是函数背后都有一个对象存在.这个对象使用 函数名.prototype 来访问. 默认情况下这个对象含有一个属性 constructor用于指向回该函数. 也就是说, 在默认情况下, 如果一个对象含有 constructor 属性, 同时,它执行某一个函数, 那么就表示这个对象是这个函数背后的 prototype. 在构造函数上，都有一个 原型属性 prototype,该属性也是一个对象( Object 的实例 )； 原型对象上有一个 constructor 属性，该属性指向 原型对象所属的构造函数 ； 而实例对象上也有一个 __proto__ 属性,该属性也指向 构造函数的原型属性 ( 即指向自己的原型对象 )，它是一个非标准属性，不可以用于编程，它是浏览器使用，便于快速访问查看实例的原型属性。 1234567 // __proto__在函数里有一个属性 prototype //prototype 与 __proto__的关系☞ __proto__ 是站在对象角度来说的☞ prototype 是站在构造函数来说的. 函数的 prototype 这个对象, 里面的所有成员( 属性, 方法 ) 都会默认的连接到这个函数作为构造函数时创建的对象上. 看图理解函数、原型和实例之间的关系( 绘制原型实例三角形 ) 注意： 凡是构造函数就有原型属性, 凡是实例对象就有原型对象. prototype 和 proto都指向同一个对象。 这个对象在构造函数角度来看, 是利用 prototype 属性获得到的, 因此将其称为 构造函数的 原型属性, 简称原型.如果站在实例对象和这个神秘对象的角度来看, 神秘对象被称为 实例对象的 原型对象, 简称为原型. 二、什么是原型链说白了，其实就是有限的实例对象和原型之间组成有限链，用来实现 属性共享 和 继承。 123456//原型链示例 var arr = []; arr -&gt; Array.prototype -&gt;Object.prototype -&gt;null var o = new Object();// var o = &#123;&#125;; o -&gt; Object.prototype -&gt; null; 三、接下来探究 继承 问题1概念：所谓的继承就是拿来主义，自己没有，别人有，拿来称为自己的，就表示你继承了这个东西。 实现继承的方法： 1. 原型继承12345678910111213141516function Animal(name)&#123; this.name = name;&#125;function Tiger(color)&#123; this.color = color;&#125;// var tiger = new Tiger('yellow');// console.log(tiger.color);// console.log(tiger.name); //undefined// Tiger.prototype = new Animal('老虎'); // 第一种方式Object.prototype.name = '大老虎'; //第二种方式var tiger = new Tiger('yellow');console.log(tiger.color);console.log(tiger.name); 2. 直接替换原型对象：12345678910111213141516171819202122Person.prototype = &#123; constructor: Person, sayHello: function () &#123;&#125;, run: function () &#123;&#125;, eat: function () &#123;&#125;, walk: function () &#123;&#125;&#125;;注意: 这个方法实际上更换的原有的原型对象. 应该注意.function Person() &#123;&#125;var p1 = new Person(); // 继承关系: p1 -&gt; 原始的原型( Person.prototype ) -&gt; Object.prototype -&gt; nullPerson.prototype = &#123; constructor: Person, sayHello: function () &#123;&#125;, run: function () &#123;&#125;, eat: function () &#123;&#125;, walk: function () &#123;&#125;&#125;;var p2 = new Person(); // 继承关系: p2 -&gt; 新的原型( 含有 sayHello 等方法的原型 ) -&gt; Object.prototype -&gt; null 注意： 它不方便给父级类型传递参数； 父级类型当中的引用类型被所有实例共享 3. 标准继承：利用 Object.creat()方法 实现继承12345678910//兼容 function create(obj)&#123; if(Object.create)&#123; return Object.create(obj); &#125;else&#123; function Foo()&#123;&#125; Foo.prototype = obj; return new Foo(); &#125; &#125; 注意：Object.create() 方法使用指定的原型对象和其属性创建了一个新的对象。它是 ES5 的新特性。语法： Object.creat( 对象 ) -&gt; 新的对象意义： 返回的新对象，原型继承自 create 方法参数中提供的对象。用途：123456789101112131415161718192021222324252627282930313233343536373839404142434445 -&gt; 1.借用已有方法实现原型式继承 场景: 数组不能遍历键值对, 我自己创建有一个构造函数, 使得我可以处理键值对,将键值对作为有序键值对来使用. 例如: var kv = &#123; name: 'jim', age: 19, gender: '男' &#125;; 例如我创建一个构造函数 SortedList, 可以将其转换成 [ &#123; key: 'name', value: 'jim' &#125;, &#123; key: 'age', value: 19 &#125;, &#123; key: 'gender', value: '男' &#125; ] 再提供一个 keys 方法与 values 方法, 分别获得所有的键 或 值 我们可以认为 SortedList 是继承自数组的对象. 实现以下: function SortedList ( kv ) &#123; // this 继承自 数组, 因此 this 应该就是数组, // 因此就应该将 kv 中每一个键值对构造成一个对象以元素的形式存储在 this 中 for ( var key in kv ) &#123; this.push(&#123; key: key, value: kv[ key ] &#125;); &#125; &#125; // SortedList.prototype = Object.create( Array.prototype ); // 简化一下 SortedList.prototype = [];-&gt; 2.提高缓存性能 var cache = &#123;&#125;; // 缓存 function __ajax__( config ) &#123; var data = config.data; // data 是一个键值对 // 将键值对拼成 请求参数 var tmp = []; for ( var key in data ) &#123; tmp.push( key + '=' + data[ key ] ); &#125; var queryString = '?' + tmp.join( '&amp;' ); console.log( queryString ); &#125; 4. 借用构造函数继承：1234567891011//被借用的构造函数中原型上的成员没有被拿来function Animal(name)&#123; this.name = name;&#125;function Mouse(nickname)&#123; Animal.call(this,'老鼠'); this.nickname = nickname;&#125;var m = new Mouse('杰瑞');console.log(m.name);console.log(m.nickname); 存在的问题： 可以解决原型继承中的传参问题，但是父类型当中的原型对象上的成员 ( 属性和方法 ) 不能被继承到。 5. 混入式继承：123456789101112131415function extend( obj ) &#123; for ( var k in obj ) &#123; this[ k ] = obj[ k ]; &#125;&#125;jQuery.extend(&#123; map: function () &#123;&#125;, each: function () &#123;&#125;&#125;);jQuery.fn.extend(&#123; map: function () &#123;&#125;, each: function () &#123;&#125;&#125;); 6. 组合继承：12345678组合: 多个东西放到一起. 组合式继承就是说把多个继承方案混合到一起使用. 就以原型式继承与混入式继承为例, 一般书写构造函数的时候都是这么实现的: 1&gt; 写一个构造函数 2&gt; 准备一个原型 3&gt; 准备一个混入方法 4&gt; 在原型中混入多个成员 5&gt; 使用构造函数创建对象, 对象就有 多个 方法了. 四、属性搜索原则 和 写入原则属性搜索原则 在访问对象的某个成员的时候会先在当前对象中查找是否存在，如果当前对象存在，停止查询； 如果当前对象中没有，就在构造函数的原型对象中查找，如果存在，停止查询； 如果原型对象中没有找到，就到原型对象的原型中查找… 直到找到或者查询到Object的原型对象的原型是 null 为止。 写入原则在 获取 一个对象的属性值或方法的时候，才会沿着原型链向下寻找， 属性赋值 没有这个，如果是给对象设置成员( 属性或方法 )，都是在当前对象上进行设置。 12345678910var obj1 = &#123;name:'one'&#125;;obj2 = Object.create(obj1);obj2.name = 'two';console.log(obj1.name);//onevar obj1 = &#123;prop:&#123;name:'one'&#125;&#125;;obj2 = Object.create(obj1);obj2.prop.name = 'two';console.log(obj1.prop.name);//two 五、拓展proto属性12345最早是 狐火在浏览器中引入, 其目的是利用实例对象观察其原型的结构. 早期没有 __proto__ 的时候, 为了观察对象的继承关系, 必须通过 实例.constructor.prototype 来获得实例对象的 原型对象. 在分析过程中非常麻烦. 因此在 火狐浏览器中给实例对象引入了 __proto__ 属性, 用于快速的访问该实例的 原型对象. 该属性带有双下划线, 表示内部属性. 后来各大浏览器也效仿, 引入该属性, 从而使用 利用实例也可以访问原型对象了( 神秘对象了 ). 1234//如果浏览器不支持 __proto__ 我们应该怎么实现该功能呢? Object.prototype.__myProto__ = function () &#123; return this.constructor.prototype; &#125;; Object.prototype 相关Object.prototype中常用成员123456789101112131415161718192021222324-&gt; hasOwnProperty 语法: 对象.hasOwnProperty( '属性的名字' ) -&gt; boolean 含义: 当前对象是否含有该属性, 意味着该属性不是原型继承而来.-&gt; isPrototypeOf 语法: 对象1.isPrototypeOf( 对象2 ) -&gt; boolean 含义: 对象1 是不是 对象2 的原型对象, 如果是 返回 true, 否则返回 false-&gt; propertyIsEnumerable 语法: 对象.prototypeIsEnumerable( '属性名' ) -&gt; boolean 含义: 对象的对应属性 如果是 自己的( 非原型中的 ) 同时可枚举( 可以 forin 出来 ), 就返回 true, 否则返回 false 注意: 所谓的 可枚举是说可以被 for-in 遍历出来 在 ES5 以前, 用户自定义的属性方法都是可以枚举的, 不允许设置为不可枚举. 在 ES5 以后, 引入了 Object.defineProperty 和 Object.defineProperties 方法, 用该方法可以定义其不可枚举.-&gt; toLocaleString 和 toString to*String 作用是将对象转换成字符串, 以供打印输出. 由于每一个对象都可以调用 to*String 方法, 但是又不清楚如何实现字符串的转换 因此 js 的作者就约定 默认的 to*String 显示出: [object 构造函数名] 如果是定义构造函数则显示 [object Object]. 然后由各个对象自己实现具体 to*String","tags":[{"name":"原型链","slug":"原型链","permalink":"https://hudadahexiaolili.github.io/tags/原型链/"},{"name":"继承","slug":"继承","permalink":"https://hudadahexiaolili.github.io/tags/继承/"}]}]